<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第二十章：认证鉴权实现 | 丢哥</title><meta name=keywords content><meta name=description content="本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：auth
在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。
一、单体模式下的认证鉴权
在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/go-rpc/auth/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/go-rpc/auth/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://diu.life/lessons/go-rpc/auth/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第二十章：认证鉴权实现"><meta property="og:description" content="本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：auth
在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。
一、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2020-02-20T00:00:00+08:00"><meta property="article:modified_time" content="2020-02-20T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第二十章：认证鉴权实现"><meta name=twitter:description content="本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：auth
在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。
一、单体模式下的认证鉴权
在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"从 0 到 1 开发一款高性能 RPC 框架","item":"https://diu.life/lessons/go-rpc/"},{"@type":"ListItem","position":3,"name":"第二十章：认证鉴权实现","item":"https://diu.life/lessons/go-rpc/auth/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第二十章：认证鉴权实现","name":"第二十章：认证鉴权实现","description":"本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：auth\n在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。\n一、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。\n","keywords":[],"articleBody":"本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：auth\n在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。\n一、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。\n客户端访问服务端时，服务端一般会用一个拦截器拦截请求，取出 session id，假如 id 合法，则可判断客户端登陆。然后查询用户的权限表，判断用户是否具有执行某次操作的权限。\n二、微服务模式下的认证鉴权 在微服务模式下，一个整体的应用可能被拆分为多个微服务，之前只有一个服务端，现在会存在多个服务端。对于客户端的单个请求，为保证安全，需要跟每个微服务都要重复上面的过程。这种模式每个微服务都要去实现相同的校验逻辑，肯定是非常冗余的。\n1、用户身份认证 为了避免每个服务端都进行重复认证，采用一个服务进行统一认证。所以考虑一个单点登录的方案，用户只需要登录一次，就可以访问所有微服务。一般在 api 的 gateway 层提供对外服务的入口，所以可以在 api gateway 层提供统一的用户认证。\n2、用户状态保持 由于 http 是一个无状态的协议，前面说到了单体模式下通过 cookie 保存用户状态， cookie 一般存储于浏览器中，用来保存用户的信息。但是 cookie 是有状态的。客户端和服务端在一次会话期间都需要维护 cookie 或者 sessionId，在微服务环境下，我们期望服务的认证是无状态的。所以我们一般采用 token 认证的方式，而非 cookie。\ntoken 由服务端用自己的密钥加密生成，在客户端登录或者完成信息校验时返回给客户端，客户端认证成功后每次向服务端发送请求带上 token，服务端根据密钥进行解密，从而校验 token 的合法，假如合法则认证通过。token 这种方式的校验不需要服务端保存会话状态，方便服务扩展。\n三、实现思路 由于业内比较通用的认证和鉴权方案比较类似，都是通过 tls 进行数据加密，通过 oauth2 进行权限校验。所以这里我们也是使用 tls + oauth2 的方式进行认证鉴权实现。这里不对 tls 和 oauth2 进行详细介绍，假如有不清楚的可以参考阮一峰老师的教程，介绍得比较清楚：\ntls ：www.ruanyifeng.com/blog/2014/0…\noauth2 ：www.ruanyifeng.com/blog/2019/0…\n这里需要补充介绍下 tls 认证的两种方式：\n单向认证：只有一个对象校验对端的证书合法性，通常是 client 校验 server 的证书合法性，例如：浏览器\n双向认证：两端都相互校验证书合法性。client 校验 server 证书，server 也校验 client 证书。一般用于银行、金融等对安全级别要求比较高的网站或者客户端\n框架默认支持单向认证。即 client 校验 server 证书。\n接下来介绍下实现思路：\n要支持 tls，需要 server 端提供证书（生产环境中一般需要 CA 签发），客户端在握手时根据 CA 的公钥来验证 server 端证书的合法性。使用 oauth2 进行权限控制，需要 client 在请求时带上 token，然后 server 去校验 token，验证 token 的正确性。这里 client 请求 token 可以在请求参数中透传，server 端对于 token 的处理，可以通过拦截器的方式进行实现。\n证书生成：\n第一步：服务端生成私钥\nopenssl ecparam -genkey -name secp384r1 -out server.key 第二步：服务端使用私钥生成证书\nopenssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650 这里需要填写一些信息（Common Name 需要填写服务名）\nCountry Name (2 letter code) []: State or Province Name (full name) []: Locality Name (eg, city) []: Organization Name (eg, company) []: Organizational Unit Name (eg, section) []: Common Name (eg, fully qualified host name) []:testAuth Email Address []: 上面生成了 server.crt 和 server.key 两个文件，我们将这两个文件放到 testdata 目录下\n四、tls 认证实现 1、接口定义 tls 认证鉴权是在传输层握手的时候进行认证，所以我们定义一个 TransportAuth 接口，这个接口包括了 client 和 server 握手的两个函数\n// TransportAuth defines a common interface for client and server handshakes type TransportAuth interface { // ClientHandshake defines a common interface for client handshakes ClientHandshake(context.Context, string, net.Conn) (net.Conn, AuthInfo, error) // ServerHandshake defines a common interface for server handshakes ServerHandshake(conn net.Conn) (net.Conn, AuthInfo, error) } 由于 go 官方包 “crypto/tls” 已经支持了 tls ，所以我们这里直接复用 “crypto/tls” 包的一些特性，主要是 tls 的配置 Config 和 连接状态 ConnectionState，\n// tlsAuth defines the implementation of TLS authentication // and implements TransportAuth, PerRPCAuth, AuthInfo type tlsAuth struct { config *tls.Config state tls.ConnectionState } 这里的 Config 信息需要通过传入的证书来获取，如下：\n// NewClientTLSAuthFromFile instantiates client-side authentication information // with certificates and service names func NewClientTLSAuthFromFile(certFile, serverName string) (TransportAuth, error) { cert , err := ioutil.ReadFile(certFile) if err != nil { return nil, err } cp := x509.NewCertPool() if !cp.AppendCertsFromPEM(cert) { return nil, codes.ClientCertFailError } conf := \u0026tls.Config { ServerName: serverName, RootCAs: cp, } return \u0026tlsAuth{config : conf}, nil } 2、实现客户端握手 这里主要思路为，先从 tls 的配置信息 Config 中获取认证信息，然后 tls.Client 方法会返回一个带有认证信息的连接 conn，然后使用这个连接 conn 进行握手，而不是原来的连接。如下：\n// ClientHandshake implements the client's handshake func (t *tlsAuth) ClientHandshake(ctx context.Context, authority string, rawConn net.Conn) (net.Conn, AuthInfo, error) { // 防止使用不同的 endpoints 时 ServerName 被污染 cfg := cloneTLSConfig(t.config) if cfg.ServerName == \"\" { colonPos := strings.LastIndex(authority, \":\") if colonPos == -1 { colonPos = len(authority) } cfg.ServerName = authority[:colonPos] } conn := tls.Client(rawConn, cfg) errChan := make(chan error, 1) go func() { errChan \u003c- conn.Handshake() }() select { case err := \u003c- errChan : if err != nil { return nil, nil, err } case \u003c- ctx.Done() : return nil, nil, ctx.Err() } return WrapConn(rawConn,conn) , \u0026tlsAuth{state : conn.ConnectionState()}, nil } 3、server 端握手实现 server 端握手实现和 client 端握手实现的思路类似，先从 tls 的配置信息 Config 中获取认证信息，然后调用 tls.Server 方法获取一个带有认证信息的连接 conn，使用这个新的 conn 进行握手。\n// the ServerHandshake implements the server handshake func (t *tlsAuth) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) { conn := tls.Server(rawConn, t.config) if err := conn.Handshake(); err != nil { return nil, nil, err } return WrapConn(rawConn,conn), \u0026tlsAuth{state : conn.ConnectionState()}, nil } 4、测试 tls 握手 测试 tls 握手的过程，这里不进行赘述，详情请参考代码：auth_test\n五、oauth2 鉴权实现 oauth2 鉴权的实现也是主要用到了 “golang.org/x/oauth2” 这个包，之前上面说到了鉴权的思路：client 请求 token 可以在请求参数中透传，server 端对于 token 的处理，可以通过拦截器的方式进行实现。\n1、接口定义 我们定义一个接口 PerRPCAuth 来表示每次进行 rpc 请求都需要进行 token 认证，这里有一个 GetMetadata 方法，主要用来定义获取 token，可以继续看下面 oauth2 是怎么获取的。\n// PerRPCAuth defines a common interface for single RPC call authentication type PerRPCAuth interface { // GetMetadata fetch custom metadata from the context GetMetadata(ctx context.Context, uri ... string) (map[string]string, error) } 2、oauth2 实现 oauth2 的实现主要是用到了 “golang.org/x/oauth2” 包的 Token 结构\ntype oAuth2 struct { token *oauth2.Token } oauth2.Token 的结构不妨也贴一下：\n// Token represents the credentials used to authorize // the requests to access protected resources on the OAuth 2.0 // provider's backend. // // Most users of this package should not access fields of Token // directly. They're exported mostly for use by related packages // implementing derivative OAuth2 flows. type Token struct { // AccessToken is the token that authorizes and authenticates // the requests. AccessToken string `json:\"access_token\"` // TokenType is the type of token. // The Type method returns either this or \"Bearer\", the default. TokenType string `json:\"token_type,omitempty\"` // RefreshToken is a token that's used by the application // (as opposed to the user) to refresh the access token // if it expires. RefreshToken string `json:\"refresh_token,omitempty\"` // Expiry is the optional expiration time of the access token. // // If zero, TokenSource implementations will reuse the same // token forever and RefreshToken or equivalent // mechanisms for that TokenSource will not be used. Expiry time.Time `json:\"expiry,omitempty\"` // raw optionally contains extra metadata from the server // when updating a token. raw interface{} } 实现了 GetMetadata 方法来进行 Token 的获取，如下：\nfunc (o *oAuth2) GetMetadata(ctx context.Context, uri ... string) (map[string]string, error) { if o.token == nil { return nil, codes.ClientCertFailError } return map[string]string{ \"authorization\": o.token.Type() + \" \" + o.token.AccessToken, }, nil } 3、token 的透传 token 如何从 client 透传到 server 呢？这里主要通过 metadata，metadata 本质是一个 k-v 键值对\ntype clientMetadata map[string][]byte type serverMetadata map[string][]byte 我们在 gorpc 协议里面 Request 和 Response 都支持了这种键值对的透传，如下：\nmessage Request { string service_path = 2; // 请求服务路径 map\u003cstring, bytes\u003e metadata = 3; // 透传的数据 bytes payload = 4; // 请求体 } message Response { uint32 ret_code = 1; // 返回码 0-正常 非0-错误 string ret_msg = 2; // 返回消息，OK-正常，错误会提示详情 map\u003cstring, bytes\u003e metadata = 3; // 透传的数据 bytes payload = 4; // 返回体 } 所以，我们只需要通过 oauth2 的 GetMetadata 获取 token 的 k-v 键值对，然后在 client 端发送请求的时候，塞到 Request 中，server 端收到请求，从 Request 取出 metadata，设置到 context 中，同时定义一个 authFunc，通过 authFunc 构造拦截器，从拦截器中取出 metadata，获取到 token 信息，然后校验 token 是否合法即可。如下：\n通过 BuildAuthInterceptor，支持传入 AuthFunc 来构造一个 server 端拦截器。\n// AuthFunc verifies that the token is valid or not type AuthFunc func(ctx context.Context) (context.Context, error) // BuildAuthFilter constructs a client interceptor with an AuthFunc func BuildAuthInterceptor(af AuthFunc) interceptor.ServerInterceptor { return func(ctx context.Context, req interface{}, handler interceptor.Handler) (interface{}, error) { newCtx, err := af(ctx) if err != nil { return nil, codes.NewFrameworkError(codes.ClientCertFail, err.Error()) } return handler(newCtx, req) } } 4、全流程解析 server 端\n业务需要定义一个 AuthFunc，这里面需要完成对 token 的校验。然后通过 gorpc.WithInterceptor(auth.BuildAuthInterceptor(af)) 来构造一个 server 端拦截器，对 rpc 请求进行拦截。\nAuthFunc 中，先通过 md := metadata.ServerMetadata(ctx) 取出 metadata，然后从 metadata 中取出 token 信息，校验 token 信息是否合法。\nfunc main() { af := func(ctx context.Context) (context.Context, error){ md := metadata.ServerMetadata(ctx) if len(md) == 0 { return ctx, errors.New(\"token nil\") } v := md[\"authorization\"] log.Debug(\"token : \", string(v)) if string(v) != \"Bearer testToken\" { return ctx, errors.New(\"token invalid\") } return ctx, nil } opts := []gorpc.ServerOption{ gorpc.WithAddress(\"127.0.0.1:8003\"), gorpc.WithNetwork(\"tcp\"), gorpc.WithSerializationType(\"msgpack\"), gorpc.WithTimeout(time.Millisecond * 2000000), gorpc.WithInterceptor(auth.BuildAuthInterceptor(af)), } s := gorpc.NewServer(opts ...) if err := s.RegisterService(\"/helloworld.Greeter\", new(testdata.Service)); err != nil { panic(err) } s.Serve() } client 端\n通过 client.WithPerRPCAuth 方法，传入一个 PerRPCAuth，这里通过调用 auth.NewOAuth2ByToken(“testToken”) 方法生成一个 token\nfunc main() { opts := []client.Option { client.WithTarget(\"127.0.0.1:8003\"), client.WithNetwork(\"tcp\"), client.WithTimeout(2000000 * time.Millisecond), client.WithSerializationType(\"msgpack\"), client.WithPerRPCAuth(auth.NewOAuth2ByToken(\"testToken\")), } c := client.DefaultClient req := \u0026testdata.HelloRequest{ Msg: \"hello\", } rsp := \u0026testdata.HelloReply{} err := c.Call(context.Background(), \"/helloworld.Greeter/SayHello\", req, rsp, opts ...) fmt.Println(rsp.Msg, err) } 我们看一下 NewOAuth2ByToken 这个方法，其实就是我们的 oauth2 包下的方法，它返回了一个 oAuth2 的对象，由于 oAuth2 实现了 PerRPCAuth 接口，所以可以通过 client.WithPerRPCAuth 直接设置每次 rpc 拦截的 token。\n// NewOAuth2ByToken supports the generation of an oauth2 based on a string token func NewOAuth2ByToken(token string) *oAuth2 { return \u0026oAuth2{ token : \u0026oauth2.Token{ AccessToken: token, }, } } 这里还差了一步，需要将 PerRPCAuth 中的 token 数据，塞到 client 的 Request 里面。这一步在 client 构造 Request 的时候完成，如下：\nfunc addReqHeader(ctx context.Context, client *defaultClient, payload []byte) *protocol.Request { clientStream := stream.GetClientStream(ctx) servicePath := fmt.Sprintf(\"/%s/%s\", clientStream.ServiceName, clientStream.Method) md := metadata.ClientMetadata(ctx) // fill the authentication information for _, pra := range client.opts.perRPCAuth { authMd, _ := pra.GetMetadata(ctx) for k, v := range authMd { md[k] = []byte(v) } } request := \u0026protocol.Request{ ServicePath: servicePath, Payload: payload, Metadata: md, } return request } 至此，我们就完成了 client 到 server token 的透传、流转和校验。\n具体代码可以参考我们的 example auth\n小结 本章节主要介绍了认证鉴权的一些基础知识、模式和常用实现。并且使用 tls 和 oauth2 实现了 gorpc 框架的认证鉴权。需要读者自行了解一些认证鉴权的基础，否则可能有些吃力。\n","wordCount":"3569","inLanguage":"zh","datePublished":"2020-02-20T00:00:00+08:00","dateModified":"2020-02-20T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/go-rpc/auth/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Go-Rpc 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/what-is-rpc/ class=chapter-link><span class=chapter-title>第一章：RPC 原理</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/rpc-framework-overview/ class=chapter-link><span class=chapter-title>第二章：RPC 框架概览</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-server/ class=chapter-link><span class=chapter-title>第三章：框架搭建 —— server</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-client/ class=chapter-link><span class=chapter-title>第四章：框架搭建 —— client</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-transport/ class=chapter-link><span class=chapter-title>第五章：框架搭建 —— transport</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/context-timeout/ class=chapter-link><span class=chapter-title>第六章：超时机制</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/custom-protocol/ class=chapter-link><span class=chapter-title>第七章：自定义协议实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/codec/ class=chapter-link><span class=chapter-title>第八章：协议编解码实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/marshal-and-unmarshal/ class=chapter-link><span class=chapter-title>第九章：序列化实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/log-component/ class=chapter-link><span class=chapter-title>第十章：日志模块实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/connection-pool/ class=chapter-link><span class=chapter-title>第十一章：连接池实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/interceptor/ class=chapter-link><span class=chapter-title>第十二章：拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/component-interface/ class=chapter-link><span class=chapter-title>第十三章：组件可插拔实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/plugin/ class=chapter-link><span class=chapter-title>第十四章：插件体系实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-selection/ class=chapter-link><span class=chapter-title>第十五章：服务发现原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-implementation/ class=chapter-link><span class=chapter-title>第十六章：服务发现实现 —— consul</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/load-balance-implementation/ class=chapter-link><span class=chapter-title>第十七章：负载均衡实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/tracing-selection/ class=chapter-link><span class=chapter-title>第十八章：分布式链路追踪原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/tracing-implementation/ class=chapter-link><span class=chapter-title>第十九章：分布式链路追踪实现 —— jaeger</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/go-rpc/auth/ class=chapter-link><span class=chapter-title>第二十章：认证鉴权实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/code-generation/ class=chapter-link><span class=chapter-title>第二十一章：代码生成工具实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-test/ class=chapter-link><span class=chapter-title>第二十二章：框架性能测试</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-optimization/ class=chapter-link><span class=chapter-title>第二十三章：框架性能优化</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/summary/ class=chapter-link><span class=chapter-title>第二十四章：总结与展望</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第二十章：认证鉴权实现</h1><div class=post-meta><time datetime=2020-02-20T00:00:00+08:00>2020-02-20</time></div></header><div class=post-content><p>本章介绍 gorpc 认证鉴权的实现，本章主要介绍原理和部分代码实现，全部代码可以参考：<a href=https://github.com/lubanproj/gorpc/tree/master/auth>auth</a></p><p>在实现 gorpc 认证鉴权之前，我们需要了解一些认证鉴权方面的知识。</p><h3 id=一单体模式下的认证鉴权>一、单体模式下的认证鉴权</h3><p>在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。</p><p>客户端访问服务端时，服务端一般会用一个拦截器拦截请求，取出 session id，假如 id 合法，则可判断客户端登陆。然后查询用户的权限表，判断用户是否具有执行某次操作的权限。</p><h3 id=二微服务模式下的认证鉴权>二、微服务模式下的认证鉴权</h3><p>在微服务模式下，一个整体的应用可能被拆分为多个微服务，之前只有一个服务端，现在会存在多个服务端。对于客户端的单个请求，为保证安全，需要跟每个微服务都要重复上面的过程。这种模式每个微服务都要去实现相同的校验逻辑，肯定是非常冗余的。</p><h4 id=1用户身份认证>1、用户身份认证</h4><p>为了避免每个服务端都进行重复认证，采用一个服务进行统一认证。所以考虑一个单点登录的方案，用户只需要登录一次，就可以访问所有微服务。一般在 api 的 gateway 层提供对外服务的入口，所以可以在 api gateway 层提供统一的用户认证。</p><h4 id=2用户状态保持>2、用户状态保持</h4><p>由于 http 是一个无状态的协议，前面说到了单体模式下通过 cookie 保存用户状态， cookie 一般存储于浏览器中，用来保存用户的信息。但是 cookie 是有状态的。客户端和服务端在一次会话期间都需要维护 cookie 或者 sessionId，在微服务环境下，我们期望服务的认证是无状态的。所以我们一般采用 token 认证的方式，而非 cookie。</p><p>token 由服务端用自己的密钥加密生成，在客户端登录或者完成信息校验时返回给客户端，客户端认证成功后每次向服务端发送请求带上 token，服务端根据密钥进行解密，从而校验 token 的合法，假如合法则认证通过。token 这种方式的校验不需要服务端保存会话状态，方便服务扩展。</p><h3 id=三实现思路>三、实现思路</h3><p>由于业内比较通用的认证和鉴权方案比较类似，都是通过 tls 进行数据加密，通过 oauth2 进行权限校验。所以这里我们也是使用 tls + oauth2 的方式进行认证鉴权实现。这里不对 tls 和 oauth2 进行详细介绍，假如有不清楚的可以参考阮一峰老师的教程，介绍得比较清楚：</p><p>tls ：<a href=http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html>www.ruanyifeng.com/blog/2014/0…</a></p><p>oauth2 ：<a href=http://www.ruanyifeng.com/blog/2019/04/oauth_design.html>www.ruanyifeng.com/blog/2019/0…</a></p><p>这里需要补充介绍下 tls 认证的两种方式：</p><p><strong>单向认证</strong>：只有一个对象校验对端的证书合法性，通常是 client 校验 server 的证书合法性，例如：浏览器</p><p><strong>双向认证</strong>：两端都相互校验证书合法性。client 校验 server 证书，server 也校验 client 证书。一般用于银行、金融等对安全级别要求比较高的网站或者客户端</p><p>框架默认支持单向认证。即 client 校验 server 证书。</p><p>接下来介绍下实现思路：</p><p>要支持 tls，需要 server 端提供证书（生产环境中一般需要 CA 签发），客户端在握手时根据 CA 的公钥来验证 server 端证书的合法性。使用 oauth2 进行权限控制，需要 client 在请求时带上 token，然后 server 去校验 token，验证 token 的正确性。这里 client 请求 token 可以在请求参数中透传，server 端对于 token 的处理，可以通过拦截器的方式进行实现。</p><p><strong>证书生成：</strong></p><p>第一步：服务端生成私钥</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>openssl</span> <span class=nx>ecparam</span> <span class=o>-</span><span class=nx>genkey</span> <span class=o>-</span><span class=nx>name</span> <span class=nx>secp384r1</span> <span class=o>-</span><span class=nx>out</span> <span class=nx>server</span><span class=p>.</span><span class=nx>key</span>
</span></span></code></pre></div><p>第二步：服务端使用私钥生成证书</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>openssl</span> <span class=nx>req</span> <span class=o>-</span><span class=nx>new</span> <span class=o>-</span><span class=nx>x509</span> <span class=o>-</span><span class=nx>sha256</span> <span class=o>-</span><span class=nx>key</span> <span class=nx>server</span><span class=p>.</span><span class=nx>key</span> <span class=o>-</span><span class=nx>out</span> <span class=nx>server</span><span class=p>.</span><span class=nx>crt</span> <span class=o>-</span><span class=nx>days</span> <span class=mi>3650</span>
</span></span></code></pre></div><p>这里需要填写一些信息（Common Name 需要填写服务名）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>Country</span> <span class=nf>Name</span> <span class=p>(</span><span class=mi>2</span> <span class=nx>letter</span> <span class=nx>code</span><span class=p>)</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl><span class=nx>State</span> <span class=nx>or</span> <span class=nx>Province</span> <span class=nf>Name</span> <span class=p>(</span><span class=nx>full</span> <span class=nx>name</span><span class=p>)</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl><span class=nx>Locality</span> <span class=nf>Name</span> <span class=p>(</span><span class=nx>eg</span><span class=p>,</span> <span class=nx>city</span><span class=p>)</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl><span class=nx>Organization</span> <span class=nf>Name</span> <span class=p>(</span><span class=nx>eg</span><span class=p>,</span> <span class=nx>company</span><span class=p>)</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl><span class=nx>Organizational</span> <span class=nx>Unit</span> <span class=nf>Name</span> <span class=p>(</span><span class=nx>eg</span><span class=p>,</span> <span class=nx>section</span><span class=p>)</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl><span class=nx>Common</span> <span class=nf>Name</span> <span class=p>(</span><span class=nx>eg</span><span class=p>,</span> <span class=nx>fully</span> <span class=nx>qualified</span> <span class=nx>host</span> <span class=nx>name</span><span class=p>)</span> <span class=p>[]:</span><span class=nx>testAuth</span>
</span></span><span class=line><span class=cl><span class=nx>Email</span> <span class=nx>Address</span> <span class=p>[]:</span>
</span></span></code></pre></div><p>上面生成了 server.crt 和 server.key 两个文件，我们将这两个文件放到 testdata 目录下</p><h3 id=四tls-认证实现>四、tls 认证实现</h3><h4 id=1接口定义>1、接口定义</h4><p>tls 认证鉴权是在传输层握手的时候进行认证，所以我们定义一个 TransportAuth 接口，这个接口包括了 client 和 server 握手的两个函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// TransportAuth defines a common interface for client and server handshakes</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TransportAuth</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// ClientHandshake defines a common interface for client handshakes</span>
</span></span><span class=line><span class=cl>   <span class=nf>ClientHandshake</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>AuthInfo</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// ServerHandshake defines a common interface for server handshakes</span>
</span></span><span class=line><span class=cl>   <span class=nf>ServerHandshake</span><span class=p>(</span><span class=nx>conn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>AuthInfo</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于 go 官方包 &ldquo;crypto/tls&rdquo; 已经支持了 tls ，所以我们这里直接复用 &ldquo;crypto/tls&rdquo; 包的一些特性，主要是 tls 的配置 Config 和 连接状态 ConnectionState，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// tlsAuth defines the implementation of TLS authentication</span>
</span></span><span class=line><span class=cl><span class=c1>// and implements TransportAuth, PerRPCAuth, AuthInfo</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>tlsAuth</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>config</span> <span class=o>*</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span>
</span></span><span class=line><span class=cl>   <span class=nx>state</span> <span class=nx>tls</span><span class=p>.</span><span class=nx>ConnectionState</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里的 Config 信息需要通过传入的证书来获取，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// NewClientTLSAuthFromFile instantiates client-side authentication information</span>
</span></span><span class=line><span class=cl><span class=c1>// with certificates and service names</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewClientTLSAuthFromFile</span><span class=p>(</span><span class=nx>certFile</span><span class=p>,</span> <span class=nx>serverName</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>TransportAuth</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>cert</span> <span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>certFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>cp</span> <span class=o>:=</span> <span class=nx>x509</span><span class=p>.</span><span class=nf>NewCertPool</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>!</span><span class=nx>cp</span><span class=p>.</span><span class=nf>AppendCertsFromPEM</span><span class=p>(</span><span class=nx>cert</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>codes</span><span class=p>.</span><span class=nx>ClientCertFailError</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>conf</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>ServerName</span><span class=p>:</span> <span class=nx>serverName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>RootCAs</span><span class=p>:</span> <span class=nx>cp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>&amp;</span><span class=nx>tlsAuth</span><span class=p>{</span><span class=nx>config</span> <span class=p>:</span> <span class=nx>conf</span><span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=2实现客户端握手>2、实现客户端握手</h4><p>这里主要思路为，先从 tls 的配置信息 Config 中获取认证信息，然后 tls.Client 方法会返回一个带有认证信息的连接 conn，然后使用这个连接 conn 进行握手，而不是原来的连接。如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ClientHandshake implements the client&#39;s handshake</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>tlsAuth</span><span class=p>)</span> <span class=nf>ClientHandshake</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>authority</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>rawConn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>AuthInfo</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 防止使用不同的 endpoints 时 ServerName 被污染</span>
</span></span><span class=line><span class=cl>   <span class=nx>cfg</span> <span class=o>:=</span> <span class=nf>cloneTLSConfig</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>ServerName</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>colonPos</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>LastIndex</span><span class=p>(</span><span class=nx>authority</span><span class=p>,</span> <span class=s>&#34;:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>colonPos</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>colonPos</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>authority</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nx>cfg</span><span class=p>.</span><span class=nx>ServerName</span> <span class=p>=</span> <span class=nx>authority</span><span class=p>[:</span><span class=nx>colonPos</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>conn</span> <span class=o>:=</span> <span class=nx>tls</span><span class=p>.</span><span class=nf>Client</span><span class=p>(</span><span class=nx>rawConn</span><span class=p>,</span> <span class=nx>cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>errChan</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>errChan</span> <span class=o>&lt;-</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Handshake</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=p>}()</span>
</span></span><span class=line><span class=cl>   <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>case</span> <span class=nx>err</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>errChan</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nf>WrapConn</span><span class=p>(</span><span class=nx>rawConn</span><span class=p>,</span><span class=nx>conn</span><span class=p>)</span> <span class=p>,</span> <span class=o>&amp;</span><span class=nx>tlsAuth</span><span class=p>{</span><span class=nx>state</span> <span class=p>:</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>ConnectionState</span><span class=p>()},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3server-端握手实现>3、server 端握手实现</h4><p>server 端握手实现和 client 端握手实现的思路类似，先从 tls 的配置信息 Config 中获取认证信息，然后调用 tls.Server 方法获取一个带有认证信息的连接 conn，使用这个新的 conn 进行握手。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// the ServerHandshake implements the server handshake</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>tlsAuth</span><span class=p>)</span> <span class=nf>ServerHandshake</span><span class=p>(</span><span class=nx>rawConn</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>AuthInfo</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>conn</span> <span class=o>:=</span> <span class=nx>tls</span><span class=p>.</span><span class=nf>Server</span><span class=p>(</span><span class=nx>rawConn</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nx>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Handshake</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nf>WrapConn</span><span class=p>(</span><span class=nx>rawConn</span><span class=p>,</span><span class=nx>conn</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>tlsAuth</span><span class=p>{</span><span class=nx>state</span> <span class=p>:</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>ConnectionState</span><span class=p>()},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=4测试-tls-握手>4、测试 tls 握手</h4><p>测试 tls 握手的过程，这里不进行赘述，详情请参考代码：<a href=https://github.com/lubanproj/gorpc/blob/master/auth/auth_test.go>auth_test</a></p><h3 id=五oauth2-鉴权实现>五、oauth2 鉴权实现</h3><p>oauth2 鉴权的实现也是主要用到了 &ldquo;golang.org/x/oauth2&rdquo; 这个包，之前上面说到了鉴权的思路：client 请求 token 可以在请求参数中透传，server 端对于 token 的处理，可以通过拦截器的方式进行实现。</p><h4 id=1接口定义-1>1、接口定义</h4><p>我们定义一个接口 PerRPCAuth 来表示每次进行 rpc 请求都需要进行 token 认证，这里有一个 GetMetadata 方法，主要用来定义获取 token，可以继续看下面 oauth2 是怎么获取的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PerRPCAuth defines a common interface for single RPC call authentication</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PerRPCAuth</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// GetMetadata fetch custom metadata from the context</span>
</span></span><span class=line><span class=cl>   <span class=nf>GetMetadata</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>uri</span> <span class=o>...</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=2oauth2-实现>2、oauth2 实现</h4><p>oauth2 的实现主要是用到了 &ldquo;golang.org/x/oauth2&rdquo; 包的 Token 结构</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>oAuth2</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>token</span> <span class=o>*</span><span class=nx>oauth2</span><span class=p>.</span><span class=nx>Token</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>oauth2.Token 的结构不妨也贴一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Token represents the credentials used to authorize</span>
</span></span><span class=line><span class=cl><span class=c1>// the requests to access protected resources on the OAuth 2.0</span>
</span></span><span class=line><span class=cl><span class=c1>// provider&#39;s backend.</span>
</span></span><span class=line><span class=cl><span class=c1>//</span>
</span></span><span class=line><span class=cl><span class=c1>// Most users of this package should not access fields of Token</span>
</span></span><span class=line><span class=cl><span class=c1>// directly. They&#39;re exported mostly for use by related packages</span>
</span></span><span class=line><span class=cl><span class=c1>// implementing derivative OAuth2 flows.</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Token</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c1>// AccessToken is the token that authorizes and authenticates</span>
</span></span><span class=line><span class=cl>   <span class=c1>// the requests.</span>
</span></span><span class=line><span class=cl>   <span class=nx>AccessToken</span> <span class=kt>string</span> <span class=s>`json:&#34;access_token&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// TokenType is the type of token.</span>
</span></span><span class=line><span class=cl>   <span class=c1>// The Type method returns either this or &#34;Bearer&#34;, the default.</span>
</span></span><span class=line><span class=cl>   <span class=nx>TokenType</span> <span class=kt>string</span> <span class=s>`json:&#34;token_type,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// RefreshToken is a token that&#39;s used by the application</span>
</span></span><span class=line><span class=cl>   <span class=c1>// (as opposed to the user) to refresh the access token</span>
</span></span><span class=line><span class=cl>   <span class=c1>// if it expires.</span>
</span></span><span class=line><span class=cl>   <span class=nx>RefreshToken</span> <span class=kt>string</span> <span class=s>`json:&#34;refresh_token,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// Expiry is the optional expiration time of the access token.</span>
</span></span><span class=line><span class=cl>   <span class=c1>//</span>
</span></span><span class=line><span class=cl>   <span class=c1>// If zero, TokenSource implementations will reuse the same</span>
</span></span><span class=line><span class=cl>   <span class=c1>// token forever and RefreshToken or equivalent</span>
</span></span><span class=line><span class=cl>   <span class=c1>// mechanisms for that TokenSource will not be used.</span>
</span></span><span class=line><span class=cl>   <span class=nx>Expiry</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span> <span class=s>`json:&#34;expiry,omitempty&#34;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// raw optionally contains extra metadata from the server</span>
</span></span><span class=line><span class=cl>   <span class=c1>// when updating a token.</span>
</span></span><span class=line><span class=cl>   <span class=nx>raw</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>实现了 GetMetadata 方法来进行 Token 的获取，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>oAuth2</span><span class=p>)</span> <span class=nf>GetMetadata</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>uri</span> <span class=o>...</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>o</span><span class=p>.</span><span class=nx>token</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>codes</span><span class=p>.</span><span class=nx>ClientCertFailError</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;authorization&#34;</span><span class=p>:</span> <span class=nx>o</span><span class=p>.</span><span class=nx>token</span><span class=p>.</span><span class=nf>Type</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=nx>o</span><span class=p>.</span><span class=nx>token</span><span class=p>.</span><span class=nx>AccessToken</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3token-的透传>3、token 的透传</h4><p>token 如何从 client 透传到 server 呢？这里主要通过 metadata，metadata 本质是一个 k-v 键值对</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>clientMetadata</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>serverMetadata</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>byte</span>
</span></span></code></pre></div><p>我们在 gorpc 协议里面 Request 和 Response 都支持了这种键值对的透传，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>message</span> <span class=nx>Request</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span>  <span class=nx>service_path</span> <span class=p>=</span> <span class=mi>2</span><span class=p>;</span>          <span class=c1>// 请求服务路径</span>
</span></span><span class=line><span class=cl>    <span class=kd>map</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=nx>bytes</span><span class=p>&gt;</span> <span class=nx>metadata</span> <span class=p>=</span> <span class=mi>3</span><span class=p>;</span>  <span class=c1>// 透传的数据</span>
</span></span><span class=line><span class=cl>    <span class=nx>bytes</span>  <span class=nx>payload</span> <span class=p>=</span> <span class=mi>4</span><span class=p>;</span>               <span class=c1>// 请求体</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>message</span> <span class=nx>Response</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32</span> <span class=nx>ret_code</span> <span class=p>=</span> <span class=mi>1</span><span class=p>;</span>               <span class=c1>// 返回码 0-正常 非0-错误</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=nx>ret_msg</span> <span class=p>=</span> <span class=mi>2</span><span class=p>;</span>                 <span class=c1>// 返回消息，OK-正常，错误会提示详情</span>
</span></span><span class=line><span class=cl>    <span class=kd>map</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=nx>bytes</span><span class=p>&gt;</span> <span class=nx>metadata</span> <span class=p>=</span> <span class=mi>3</span><span class=p>;</span>   <span class=c1>// 透传的数据</span>
</span></span><span class=line><span class=cl>    <span class=nx>bytes</span> <span class=nx>payload</span> <span class=p>=</span> <span class=mi>4</span><span class=p>;</span>                 <span class=c1>// 返回体</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>所以，我们只需要通过 oauth2 的 GetMetadata 获取 token 的 k-v 键值对，然后在 client 端发送请求的时候，塞到 Request 中，server 端收到请求，从 Request 取出 metadata，设置到 context 中，同时定义一个 authFunc，通过 authFunc 构造拦截器，从拦截器中取出 metadata，获取到 token 信息，然后校验 token 是否合法即可。如下：</p><p>通过 BuildAuthInterceptor，支持传入 AuthFunc 来构造一个 server 端拦截器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// AuthFunc verifies that the token is valid or not</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>AuthFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// BuildAuthFilter constructs a client interceptor with an AuthFunc</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BuildAuthInterceptor</span><span class=p>(</span><span class=nx>af</span> <span class=nx>AuthFunc</span><span class=p>)</span> <span class=nx>interceptor</span><span class=p>.</span><span class=nx>ServerInterceptor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>handler</span> <span class=nx>interceptor</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>newCtx</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>af</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>codes</span><span class=p>.</span><span class=nf>NewFrameworkError</span><span class=p>(</span><span class=nx>codes</span><span class=p>.</span><span class=nx>ClientCertFail</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>handler</span><span class=p>(</span><span class=nx>newCtx</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=4全流程解析>4、全流程解析</h4><p><strong>server 端</strong></p><p>业务需要定义一个 AuthFunc，这里面需要完成对 token 的校验。然后通过 gorpc.WithInterceptor(auth.BuildAuthInterceptor(af)) 来构造一个 server 端拦截器，对 rpc 请求进行拦截。</p><p>AuthFunc 中，先通过 md := metadata.ServerMetadata(ctx) 取出 metadata，然后从 metadata 中取出 token 信息，校验 token 信息是否合法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>af</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>error</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nx>md</span> <span class=o>:=</span> <span class=nx>metadata</span><span class=p>.</span><span class=nf>ServerMetadata</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>md</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>ctx</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;token nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nx>v</span> <span class=o>:=</span> <span class=nx>md</span><span class=p>[</span><span class=s>&#34;authorization&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=nx>log</span><span class=p>.</span><span class=nf>Debug</span><span class=p>(</span><span class=s>&#34;token : &#34;</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nb>string</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=o>!=</span> <span class=s>&#34;Bearer testToken&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>ctx</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;token invalid&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>ctx</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>opts</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>gorpc</span><span class=p>.</span><span class=nx>ServerOption</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>gorpc</span><span class=p>.</span><span class=nf>WithAddress</span><span class=p>(</span><span class=s>&#34;127.0.0.1:8003&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>gorpc</span><span class=p>.</span><span class=nf>WithNetwork</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>gorpc</span><span class=p>.</span><span class=nf>WithSerializationType</span><span class=p>(</span><span class=s>&#34;msgpack&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>gorpc</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=mi>2000000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>gorpc</span><span class=p>.</span><span class=nf>WithInterceptor</span><span class=p>(</span><span class=nx>auth</span><span class=p>.</span><span class=nf>BuildAuthInterceptor</span><span class=p>(</span><span class=nx>af</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>s</span> <span class=o>:=</span> <span class=nx>gorpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>opts</span> <span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>RegisterService</span><span class=p>(</span><span class=s>&#34;/helloworld.Greeter&#34;</span><span class=p>,</span> <span class=nb>new</span><span class=p>(</span><span class=nx>testdata</span><span class=p>.</span><span class=nx>Service</span><span class=p>));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>s</span><span class=p>.</span><span class=nf>Serve</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>client 端</strong></p><p>通过 client.WithPerRPCAuth 方法，传入一个 PerRPCAuth，这里通过调用 auth.NewOAuth2ByToken(&ldquo;testToken&rdquo;) 方法生成一个 token</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>opts</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>client</span><span class=p>.</span><span class=nx>Option</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>client</span><span class=p>.</span><span class=nf>WithTarget</span><span class=p>(</span><span class=s>&#34;127.0.0.1:8003&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>client</span><span class=p>.</span><span class=nf>WithNetwork</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>client</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=mi>2000000</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>client</span><span class=p>.</span><span class=nf>WithSerializationType</span><span class=p>(</span><span class=s>&#34;msgpack&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>client</span><span class=p>.</span><span class=nf>WithPerRPCAuth</span><span class=p>(</span><span class=nx>auth</span><span class=p>.</span><span class=nf>NewOAuth2ByToken</span><span class=p>(</span><span class=s>&#34;testToken&#34;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>c</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>DefaultClient</span>
</span></span><span class=line><span class=cl>   <span class=nx>req</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>testdata</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>Msg</span><span class=p>:</span> <span class=s>&#34;hello&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>rsp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>testdata</span><span class=p>.</span><span class=nx>HelloReply</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>   <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;/helloworld.Greeter/SayHello&#34;</span><span class=p>,</span> <span class=nx>req</span><span class=p>,</span> <span class=nx>rsp</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>rsp</span><span class=p>.</span><span class=nx>Msg</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们看一下 NewOAuth2ByToken 这个方法，其实就是我们的 oauth2 包下的方法，它返回了一个 oAuth2 的对象，由于 oAuth2 实现了 PerRPCAuth 接口，所以可以通过 client.WithPerRPCAuth 直接设置每次 rpc 拦截的 token。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// NewOAuth2ByToken supports the generation of an oauth2 based on a string token</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewOAuth2ByToken</span><span class=p>(</span><span class=nx>token</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>oAuth2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>&amp;</span><span class=nx>oAuth2</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>token</span> <span class=p>:</span> <span class=o>&amp;</span><span class=nx>oauth2</span><span class=p>.</span><span class=nx>Token</span><span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>AccessToken</span><span class=p>:</span> <span class=nx>token</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里还差了一步，需要将 PerRPCAuth 中的 token 数据，塞到 client 的 Request 里面。这一步在 client 构造 Request 的时候完成，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>addReqHeader</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>client</span> <span class=o>*</span><span class=nx>defaultClient</span><span class=p>,</span> <span class=nx>payload</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=o>*</span><span class=nx>protocol</span><span class=p>.</span><span class=nx>Request</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>clientStream</span> <span class=o>:=</span> <span class=nx>stream</span><span class=p>.</span><span class=nf>GetClientStream</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>servicePath</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;/%s/%s&#34;</span><span class=p>,</span> <span class=nx>clientStream</span><span class=p>.</span><span class=nx>ServiceName</span><span class=p>,</span> <span class=nx>clientStream</span><span class=p>.</span><span class=nx>Method</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>md</span> <span class=o>:=</span> <span class=nx>metadata</span><span class=p>.</span><span class=nf>ClientMetadata</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// fill the authentication information</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>pra</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>client</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>perRPCAuth</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>authMd</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>pra</span><span class=p>.</span><span class=nf>GetMetadata</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>authMd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>md</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>request</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>protocol</span><span class=p>.</span><span class=nx>Request</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>ServicePath</span><span class=p>:</span> <span class=nx>servicePath</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>Payload</span><span class=p>:</span> <span class=nx>payload</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>Metadata</span><span class=p>:</span> <span class=nx>md</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>request</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>至此，我们就完成了 client 到 server token 的透传、流转和校验。</p><p>具体代码可以参考我们的 example <a href=https://github.com/lubanproj/gorpc/tree/master/examples/auth>auth</a></p><h3 id=小结>小结</h3><p>本章节主要介绍了认证鉴权的一些基础知识、模式和常用实现。并且使用 tls 和 oauth2 实现了 gorpc 框架的认证鉴权。需要读者自行了解一些认证鉴权的基础，否则可能有些吃力。</p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/go-rpc/tracing-implementation/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第十九章：分布式链路追踪实现 —— jaeger</span>
</a><a href=https://diu.life/lessons/go-rpc/code-generation/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第二十一章：代码生成工具实现</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2021 丢哥 all rights reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>