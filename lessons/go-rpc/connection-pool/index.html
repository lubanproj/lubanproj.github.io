<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第十一章：连接池实现 | 丢哥</title><meta name=keywords content><meta name=description content="一、为什么需要连接池
连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/go-rpc/connection-pool/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/go-rpc/connection-pool/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://diu.life/lessons/go-rpc/connection-pool/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第十一章：连接池实现"><meta property="og:description" content="一、为什么需要连接池 连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2020-02-11T00:00:00+08:00"><meta property="article:modified_time" content="2020-02-11T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第十一章：连接池实现"><meta name=twitter:description content="一、为什么需要连接池
连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"从 0 到 1 开发一款高性能 RPC 框架","item":"https://diu.life/lessons/go-rpc/"},{"@type":"ListItem","position":3,"name":"第十一章：连接池实现","item":"https://diu.life/lessons/go-rpc/connection-pool/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第十一章：连接池实现","name":"第十一章：连接池实现","description":"一、为什么需要连接池 连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。\n","keywords":[],"articleBody":"一、为什么需要连接池 连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。\n二、连接池需要解决的几个问题 上面我们说了为什么需要连接池，为了提高性能和避免端口不够用的情况。那么连接池需要解决那些问题呢？我们先思考下，然后列举如下：\n1、连接如何管理\n2、连接的创建和销毁过程\n3、连接如何进行复用\n4、如何判断连接失效，连接何时关闭\n5、如何做到并发安全\n其实，我们把这些问题解决完之后，发现一个连接池基本就已经被实现了。\n三、连接池的具体实现 1、连接如何管理 假如把连接如何管理这个问题拆分一下，可以分解为两个问题：\n（1）连接用什么数据结构管理？\n（2）在一个 client 中可能会对多个下游发起调用，这里就会存在多种不同 server 的连接。那么多个 server 连接如何管理，是用一个连接池管理还是多个连接池管理？\n针对第一个问题，对管理连接的数据结构的选择，可以有数组、链表、队列、channel 等进行管理。channel 是 go 里面特有的数据结构，能够天然用于 go 不同协程之间的通信。所以这里我们用 channel 来进行实现。当然你也可以使用其他数据结构，比如 redigo 就是用的双向链表实现。\n针对第二个问题，不同类型的连接如何管理？假如是多个连接池管理的话，一种后端 server 地址一个连接池进行管理。这些连接池拥有一些相同的参数，比如初始连接数，最大连接数，空闲连接数，连接的空闲时间等。子连接池的结构如下所示：\ntype channelPool struct { net.Conn initialCap int // initial capacity maxCap int // max capacity maxIdle int // max idle conn number idleTimeout time.Duration // idle timeout dialTimeout time.Duration // dial timeout Dial func(context.Context) (net.Conn, error) conns chan *PoolConn mu sync.Mutex } 这些参数的管理我们希望是统一化管理的，所以我们可以用一个大的连接池进行管理。用一个 map 来管理不同的 server 子连接池，map 的 key 是 server 的监听地址，value 是子连接池。所以，在子连接池 channelPool 的基础上，我们再定义一个全局 pool，结构如下：\ntype pool struct { opts *Options conns *sync.Map } 2、连接的创建和销毁 （1）连接什么时候创建？\n连接的创建都是在子连接池里面进行。首先需要子连接池先初始化。假如用户设置了初始连接数 initialCap，例如 initialCap = 5，此时我们在创建子连接池的时候，就要初始化创建 5 个连接。那么子连接池什么时候初始化呢？因为一个子连接池对应一个后端 server 地址，这个地址参数只有在 client 发起调用时才会传入，所以在 client 调用 Get 方法获取连接 net.Conn 时，假如这个调用的后端 server 地址 address 是第一次调用，那么我们将会去初始化这个 address 的子连接池。\n如下：\nfunc (p *pool) Get(ctx context.Context, network string, address string) (net.Conn, error) { if value, ok := p.conns.Load(address); ok { if cp, ok := value.(*channelPool); ok { conn, err := cp.Get(ctx) return conn, err } } cp, err := p.NewChannelPool(ctx, network, address) if err != nil { return nil, err } p.conns.Store(address, cp) return cp.Get(ctx) } 上面这段逻辑是先从 map 中取出 key 为 address 的子连接池，假如不存在，那么说明是第一次调用，创建 后端 server 地址为 address 的子连接池，创建的核心逻辑如下：\nfunc (p *pool) NewChannelPool(ctx context.Context, network string, address string) (*channelPool, error){ c := \u0026channelPool { initialCap: p.opts.initialCap, maxCap: p.opts.maxCap, Dial : func(ctx context.Context) (net.Conn, error) { select { case \u003c-ctx.Done(): return nil, ctx.Err() default: } timeout := p.opts.dialTimeout if t , ok := ctx.Deadline(); ok { timeout = t.Sub(time.Now()) } return net.DialTimeout(network, address, timeout) }, conns : make(chan *PoolConn, p.opts.maxCap), idleTimeout: p.opts.idleTimeout, dialTimeout: p.opts.dialTimeout, } ... return c, nil } Dial 这个方法则是 client 向 server 发起后端调用的方法，要获取连接，最终还是调用 Dial 这个方法来得到一个连接。这里还引入了一个 context 进行上下文和超时控制。\n所以我们就可以回答这个问题，子连接池初始化是在第一次 client 调用 pool.Get 方法获取连接的时候进行的。client 连接的创建是通过调用子连接池的 Dial 方法进行创建，创建时机也是在 pool.Get 的时候进行，子连接池初始化创建 address 地址的 server 连接个数由 initialCap 这个参数去指定。\n（2）连接什么时候销毁\n我们使用连接池的目的就是为了连接复用，那么问题来了，既然连接池里面的连接是复用的，是不是可以被无限使用下去呢？\n答案肯定是否定的。那我们怎么判断一个连接什么时候该从连接池中销毁掉呢？这里首先需要明确一点，client 是不断发送请求，server 是不断进行请求监听，所以这里我们把对连接的状态管理放在了 client 端。server 端发现连接异常，则进行关闭，所以，连接池 pool 是被用在 client。\n那么 pool 怎么知道什么时候该进行连接销毁呢？这里有两种情况。\n第一种是连接已经 ”坏掉了“。这里 “坏掉了” 指的就是 server 关闭连接了，server 关闭连接，出现在 server 从 client 读写数据时，出现了异常，或者是出现了 io.EOF 这个错误，这个错误一般说明对端（client）已经关闭连接了。此时，说明这个连接是坏掉的，我们用一个标识 unusable 表明这个连接已经 ”坏掉“、不可用了。\n第二种情况是连接已经闲置非常久了，因为我们为了实现连接复用和提高传输层效率，采用的是 tcp 长连接的方式。既然是长连接，假如这个连接已经很久没有被使用了，它也不会被关闭。这个时候 client 和 server 之间已经没有需要传输的数据了，我们为了避免资源浪费，就应该把这个连接给关闭，也就是销毁。\n解决方案\n针对第一种情况，非常好解决。我们只需要在进行读写数据时，发现出错了，就将连接置为不可用（unusable 设置为 true），并将连接关闭即可，如下：\nfunc (p *PoolConn) Read(b []byte) (int, error) { if p.unusable { return 0, ErrConnClosed } n, err := p.Conn.Read(b) if err != nil { p.MarkUnusable() p.Conn.Close() } return n, err } func (p *PoolConn) Write(b []byte) (int, error) { if p.unusable { return 0, ErrConnClosed } n, err := p.Conn.Write(b) if err != nil { p.MarkUnusable() p.Conn.Close() } return n, err } 针对第二种情况，就相对复杂一点，这里我们采取的办法是 client 定时检查连接的状态，发现失效或者是闲置的连接，则进行销毁。这里是用一个独立的协程实现的，相当于健康检查。如下：\n// checker 函数负责校验连接是否存活 func (c *channelPool) RegisterChecker(internal time.Duration, checker func(conn *PoolConn) bool) { if internal \u003c= 0 || checker == nil { return } go func() { for { time.Sleep(internal) length := len(c.conns) for i:=0; i \u003c length; i++ { select { case pc := \u003c- c.conns : if !checker(pc) { pc.MarkUnusable() pc.Close() break } else { c.Put(pc) } default: break } } } }() } checker 函数负责校验连接是否存活或者闲置，如下：\nfunc (c *channelPool) Checker (pc *PoolConn) bool { // check timeout if pc.t.Add(c.idleTimeout).Before(time.Now()) { return false } // check conn is alive or not if !isConnAlive(pc.Conn) { return false } return true } 3、连接如何进行复用 连接不复用之前的请求流程是 client 通过 Dial 获取一个到指定 address 的连接 Conn。后续的请求用这个Conn 进行处理，处理完之后对这个连接 Conn 进行关闭。server 监听到一个连接后，用连接 Conn 处理请求、返回响应，然后把连接关闭。如下：\n那我们思考一下，假如需要进行连接复用，那么对于 client 而言，每次 conn 处理完之后，不能直接 Close，而是需要进行判断，假如连接是健康的，那么则需要把它加入我们的 channel 里面进行复用。对于 server 而言，由于 server 监听到一个请求，是循环进行读写的。只有在读写异常的时候进行连接 Conn 的关闭，所以这了只要 client 不关闭连接，且连接 Conn 是健康的，那么 server 就不会进行关闭。\n所以这里的实现就是使用装饰者模式，对 Close 进行修饰，调用 Close 时，先判断 unusable 这个字段的值（假如连接异常 unusable 会被置为 true），假如 unusable 为 true（连接异常）则关闭，否则，则放入连接池中进行复用。如下：\n// overwrite conn Close for connection reuse func (p *PoolConn) Close() error { p.mu.RLock() defer p.mu.RUnlock() if p.unusable { if p.Conn != nil { return p.Conn.Close() } } // reset connection deadline p.Conn.SetDeadline(time.Time{}) return p.c.Put(p) } 需要说明一下的是 PoolConn 这个结构体，它结构如下：\ntype PoolConn struct { net.Conn c *channelPool unusable bool // if unusable is true, the conn should be closed mu sync.RWMutex t time.Time // connection idle time dialTimeout time.Duration // connection timeout duration } 可以看到它是对原生连接 net.Conn 进行了修饰。它修饰了 net.Conn 的 Read、Write、Close 方法。Read 和 Write 上面也提到过，读失败会将 unusable 这个标志置为 true，表示连接异常，不可用了。写失败也会这样。同时在 Close 之前会判断 unusable 这个标志位，发现连接健康才会扔回池子里进行复用。\n4、连接何时失效、何时关闭 在解决问题 1、2、3 的过程中，我们发现，其实问题 4 已经被解决了。连接在失效或者被闲置过久则关闭。\n连接在读写失败或者发现对端关闭的时候失效，即将 unusable 置为 true，表示连接异常、不可用。\n5、如何实现并发安全 由于我们是全局使用一个连接池对象来管理连接。那么这个连接池对象是所有协程共用的。这样就会牵涉到并发安全的问题。那么我们如何去实现并发安全呢？在 go 里面实现并发安全其实也比较简单，我们主要使用到互斥锁和并发安全的工具 sync.Map\n（1）全局连接池对象 pool\n全局连接池对象是所有协程共用的。它主要是实现对所有子连接池的统一管理，这里为了保证并发安全，通过一个并发安全的工具 sync.Map 来进行实现。\ntype pool struct { opts *Options conns *sync.Map } （2）子连接池 channelPool\ntype channelPool struct { net.Conn initialCap int // initial capacity maxCap int // max capacity maxIdle int // max idle conn number idleTimeout time.Duration // idle timeout dialTimeout time.Duration // dial timeout Dial func(context.Context) (net.Conn, error) conns chan *PoolConn mu sync.Mutex } 子连接池 pool 实现对某类 address 的 server 连接管理。这里主要是使用了互斥锁 sync.Mutex 来保证并发安全。所有的写操作都会进行加锁。\n（3）具体的连接类 PoolConn\ntype PoolConn struct { net.Conn c *channelPool unusable bool // if unusable is true, the conn should be closed mu sync.RWMutex t time.Time // connection idle time dialTimeout time.Duration // connection timeout duration } PoolConn 通过装饰者模式对原生连接 net.Conn 进行了修饰。这里也是通过互斥锁来保证并发安全，只不过这里粒度更细，用了读写锁 sync.RWMutex。\n更多细节可以参考 pool\n小结 本章主要介绍了连接池 pool 的实现。包括对连接的管理、连接的创建和销毁、连接的复用、连接失效的健康检查以及如何实现并发安全等。本章内容较多，大家可以好好再详细梳理一下。\n","wordCount":"3582","inLanguage":"zh","datePublished":"2020-02-11T00:00:00+08:00","dateModified":"2020-02-11T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/go-rpc/connection-pool/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Go-Rpc 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/what-is-rpc/ class=chapter-link><span class=chapter-title>第一章：RPC 原理</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/rpc-framework-overview/ class=chapter-link><span class=chapter-title>第二章：RPC 框架概览</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-server/ class=chapter-link><span class=chapter-title>第三章：框架搭建 —— server</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-client/ class=chapter-link><span class=chapter-title>第四章：框架搭建 —— client</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-transport/ class=chapter-link><span class=chapter-title>第五章：框架搭建 —— transport</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/context-timeout/ class=chapter-link><span class=chapter-title>第六章：超时机制</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/custom-protocol/ class=chapter-link><span class=chapter-title>第七章：自定义协议实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/codec/ class=chapter-link><span class=chapter-title>第八章：协议编解码实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/marshal-and-unmarshal/ class=chapter-link><span class=chapter-title>第九章：序列化实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/log-component/ class=chapter-link><span class=chapter-title>第十章：日志模块实现</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/go-rpc/connection-pool/ class=chapter-link><span class=chapter-title>第十一章：连接池实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/interceptor/ class=chapter-link><span class=chapter-title>第十二章：拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/component-interface/ class=chapter-link><span class=chapter-title>第十三章：组件可插拔实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/plugin/ class=chapter-link><span class=chapter-title>第十四章：插件体系实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-selection/ class=chapter-link><span class=chapter-title>第十五章：服务发现原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-implementation/ class=chapter-link><span class=chapter-title>第十六章：服务发现实现 —— consul</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/load-balance-implementation/ class=chapter-link><span class=chapter-title>第十七章：负载均衡实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/tracing-selection/ class=chapter-link><span class=chapter-title>第十八章：分布式链路追踪原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/tracing-implementation/ class=chapter-link><span class=chapter-title>第十九章：分布式链路追踪实现 —— jaeger</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/auth/ class=chapter-link><span class=chapter-title>第二十章：认证鉴权实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/code-generation/ class=chapter-link><span class=chapter-title>第二十一章：代码生成工具实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-test/ class=chapter-link><span class=chapter-title>第二十二章：框架性能测试</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-optimization/ class=chapter-link><span class=chapter-title>第二十三章：框架性能优化</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/summary/ class=chapter-link><span class=chapter-title>第二十四章：总结与展望</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第十一章：连接池实现</h1><div class=post-meta><time datetime=2020-02-11T00:00:00+08:00>2020-02-11</time></div></header><div class=post-content><h3 id=一为什么需要连接池>一、为什么需要连接池</h3><p>连接池是一个创建和管理连接的缓冲池技术。为什么需要连接池呢？我们知道，client 每次向 server 发起请求都会创建一个连接。一般一个 rpc 请求消耗的时间可能是几百毫秒到几秒，也就是说在一个比较短的时间内，这个连接就会被销毁。假设我们一秒钟需要处理 20w 个请求，假如不使用连接池的话，可能几万十几万的连接在短时间内都会被创建和销毁，这对 cpu 资源是一个很大的消耗，同时因为我们的端口数是 1~65535，除了一些端口被计算机内部占用，每次 client 创建连接都需要分配一个端口，假如并发量过大的话，可能会出现计算机端口不够用的情况。</p><h3 id=二连接池需要解决的几个问题>二、连接池需要解决的几个问题</h3><p>上面我们说了为什么需要连接池，为了提高性能和避免端口不够用的情况。那么连接池需要解决那些问题呢？我们先思考下，然后列举如下：</p><p>1、连接如何管理</p><p>2、连接的创建和销毁过程</p><p>3、连接如何进行复用</p><p>4、如何判断连接失效，连接何时关闭</p><p>5、如何做到并发安全</p><p>其实，我们把这些问题解决完之后，发现一个连接池基本就已经被实现了。</p><h3 id=三连接池的具体实现>三、连接池的具体实现</h3><h4 id=1连接如何管理>1、连接如何管理</h4><p>假如把连接如何管理这个问题拆分一下，可以分解为两个问题：</p><p>（1）连接用什么数据结构管理？</p><p>（2）在一个 client 中可能会对多个下游发起调用，这里就会存在多种不同 server 的连接。那么多个 server 连接如何管理，是用一个连接池管理还是多个连接池管理？</p><p>针对第一个问题，对管理连接的数据结构的选择，可以有数组、链表、队列、channel 等进行管理。channel 是 go 里面特有的数据结构，能够天然用于 go 不同协程之间的通信。所以这里我们用 channel 来进行实现。当然你也可以使用其他数据结构，比如 redigo 就是用的双向链表实现。</p><p>针对第二个问题，不同类型的连接如何管理？假如是多个连接池管理的话，一种后端 server 地址一个连接池进行管理。这些连接池拥有一些相同的参数，比如初始连接数，最大连接数，空闲连接数，连接的空闲时间等。子连接池的结构如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>channelPool</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span>
</span></span><span class=line><span class=cl>   <span class=nx>initialCap</span> <span class=kt>int</span>  <span class=c1>// initial capacity</span>
</span></span><span class=line><span class=cl>   <span class=nx>maxCap</span> <span class=kt>int</span>      <span class=c1>// max capacity</span>
</span></span><span class=line><span class=cl>   <span class=nx>maxIdle</span> <span class=kt>int</span>     <span class=c1>// max idle conn number</span>
</span></span><span class=line><span class=cl>   <span class=nx>idleTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>  <span class=c1>// idle timeout</span>
</span></span><span class=line><span class=cl>   <span class=nx>dialTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>  <span class=c1>// dial timeout</span>
</span></span><span class=line><span class=cl>   <span class=nx>Dial</span> <span class=kd>func</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>conns</span> <span class=kd>chan</span> <span class=o>*</span><span class=nx>PoolConn</span>
</span></span><span class=line><span class=cl>   <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这些参数的管理我们希望是统一化管理的，所以我们可以用一个大的连接池进行管理。用一个 map 来管理不同的 server 子连接池，map 的 key 是 server 的监听地址，value 是子连接池。所以，在子连接池 channelPool 的基础上，我们再定义一个全局 pool，结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pool</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>opts</span> <span class=o>*</span><span class=nx>Options</span>
</span></span><span class=line><span class=cl>   <span class=nx>conns</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=2连接的创建和销毁>2、连接的创建和销毁</h3><p>（1）连接什么时候创建？</p><p>连接的创建都是在子连接池里面进行。首先需要子连接池先初始化。假如用户设置了初始连接数 initialCap，例如 initialCap = 5，此时我们在创建子连接池的时候，就要初始化创建 5 个连接。那么子连接池什么时候初始化呢？因为一个子连接池对应一个后端 server 地址，这个地址参数只有在 client 发起调用时才会传入，所以在 client 调用 Get 方法获取连接 net.Conn 时，假如这个调用的后端 server 地址 address 是第一次调用，那么我们将会去初始化这个 address 的子连接池。</p><p>如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>pool</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>network</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conns</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>address</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>cp</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>value</span><span class=p>.(</span><span class=o>*</span><span class=nx>channelPool</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cp</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>cp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>NewChannelPool</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>network</span><span class=p>,</span> <span class=nx>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>p</span><span class=p>.</span><span class=nx>conns</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span> <span class=nx>cp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>cp</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面这段逻辑是先从 map 中取出 key 为 address 的子连接池，假如不存在，那么说明是第一次调用，创建 后端 server 地址为 address 的子连接池，创建的核心逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>pool</span><span class=p>)</span> <span class=nf>NewChannelPool</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>network</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>channelPool</span><span class=p>,</span> <span class=kt>error</span><span class=p>){</span>
</span></span><span class=line><span class=cl>   <span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>channelPool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>initialCap</span><span class=p>:</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>initialCap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>maxCap</span><span class=p>:</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>maxCap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>Dial</span> <span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>         <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=nx>timeout</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>dialTimeout</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=nx>t</span> <span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Deadline</span><span class=p>();</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>timeout</span> <span class=p>=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>())</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>net</span><span class=p>.</span><span class=nf>DialTimeout</span><span class=p>(</span><span class=nx>network</span><span class=p>,</span> <span class=nx>address</span><span class=p>,</span> <span class=nx>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=nx>conns</span> <span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>maxCap</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>idleTimeout</span><span class=p>:</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>idleTimeout</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>dialTimeout</span><span class=p>:</span> <span class=nx>p</span><span class=p>.</span><span class=nx>opts</span><span class=p>.</span><span class=nx>dialTimeout</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=o>...</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>c</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dial 这个方法则是 client 向 server 发起后端调用的方法，要获取连接，最终还是调用 Dial 这个方法来得到一个连接。这里还引入了一个 context 进行上下文和超时控制。</p><p>所以我们就可以回答这个问题，子连接池初始化是在第一次 client 调用 pool.Get 方法获取连接的时候进行的。client 连接的创建是通过调用子连接池的 Dial 方法进行创建，创建时机也是在 pool.Get 的时候进行，子连接池初始化创建 address 地址的 server 连接个数由 initialCap 这个参数去指定。</p><p>（2）连接什么时候销毁</p><p>我们使用连接池的目的就是为了连接复用，那么问题来了，既然连接池里面的连接是复用的，是不是可以被无限使用下去呢？</p><p>答案肯定是否定的。那我们怎么判断一个连接什么时候该从连接池中销毁掉呢？这里首先需要明确一点，client 是不断发送请求，server 是不断进行请求监听，所以这里我们把对连接的状态管理放在了 client 端。server 端发现连接异常，则进行关闭，所以，连接池 pool 是被用在 client。</p><p>那么 pool 怎么知道什么时候该进行连接销毁呢？这里有两种情况。</p><p>第一种是连接已经 ”坏掉了“。这里 “坏掉了” 指的就是 server 关闭连接了，server 关闭连接，出现在 server 从 client 读写数据时，出现了异常，或者是出现了 io.EOF 这个错误，这个错误一般说明对端（client）已经关闭连接了。此时，说明这个连接是坏掉的，我们用一个标识 unusable 表明这个连接已经 ”坏掉“、不可用了。</p><p>第二种情况是连接已经闲置非常久了，因为我们为了实现连接复用和提高传输层效率，采用的是 tcp 长连接的方式。既然是长连接，假如这个连接已经很久没有被使用了，它也不会被关闭。这个时候 client 和 server 之间已经没有需要传输的数据了，我们为了避免资源浪费，就应该把这个连接给关闭，也就是销毁。</p><p><strong>解决方案</strong></p><p>针对第一种情况，非常好解决。我们只需要在进行读写数据时，发现出错了，就将连接置为不可用（unusable 设置为 true），并将连接关闭即可，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>unusable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>ErrConnClosed</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>.</span><span class=nf>MarkUnusable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>unusable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>ErrConnClosed</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>.</span><span class=nf>MarkUnusable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>针对第二种情况，就相对复杂一点，这里我们采取的办法是 client 定时检查连接的状态，发现失效或者是闲置的连接，则进行销毁。这里是用一个独立的协程实现的，相当于健康检查。如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// checker 函数负责校验连接是否存活</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>channelPool</span><span class=p>)</span> <span class=nf>RegisterChecker</span><span class=p>(</span><span class=nx>internal</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>,</span> <span class=nx>checker</span> <span class=kd>func</span><span class=p>(</span><span class=nx>conn</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>internal</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>checker</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>internal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>length</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>conns</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=nx>pc</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>c</span><span class=p>.</span><span class=nx>conns</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=p>!</span><span class=nf>checker</span><span class=p>(</span><span class=nx>pc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>pc</span><span class=p>.</span><span class=nf>MarkUnusable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>						<span class=nx>pc</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>						<span class=k>break</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>c</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>pc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>					<span class=k>break</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>checker 函数负责校验连接是否存活或者闲置，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>channelPool</span><span class=p>)</span> <span class=nf>Checker</span> <span class=p>(</span><span class=nx>pc</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// check timeout</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>pc</span><span class=p>.</span><span class=nx>t</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>idleTimeout</span><span class=p>).</span><span class=nf>Before</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// check conn is alive or not</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>!</span><span class=nf>isConnAlive</span><span class=p>(</span><span class=nx>pc</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=3连接如何进行复用>3、连接如何进行复用</h3><p>连接不复用之前的请求流程是 client 通过 Dial 获取一个到指定 address 的连接 Conn。后续的请求用这个Conn 进行处理，处理完之后对这个连接 Conn 进行关闭。server 监听到一个连接后，用连接 Conn 处理请求、返回响应，然后把连接关闭。如下：</p><p><img alt=img loading=lazy src=/images/go-rpc/11-1.jpg></p><p>那我们思考一下，假如需要进行连接复用，那么对于 client 而言，每次 conn 处理完之后，不能直接 Close，而是需要进行判断，假如连接是健康的，那么则需要把它加入我们的 channel 里面进行复用。对于 server 而言，由于 server 监听到一个请求，是循环进行读写的。只有在读写异常的时候进行连接 Conn 的关闭，所以这了只要 client 不关闭连接，且连接 Conn 是健康的，那么 server 就不会进行关闭。</p><p>所以这里的实现就是使用装饰者模式，对 Close 进行修饰，调用 Close 时，先判断 unusable 这个字段的值（假如连接异常 unusable 会被置为 true），假如 unusable 为 true（连接异常）则关闭，否则，则放入连接池中进行复用。如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// overwrite conn Close for connection reuse</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PoolConn</span><span class=p>)</span> <span class=nf>Close</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>unusable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// reset connection deadline</span>
</span></span><span class=line><span class=cl>   <span class=nx>p</span><span class=p>.</span><span class=nx>Conn</span><span class=p>.</span><span class=nf>SetDeadline</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>需要说明一下的是 PoolConn 这个结构体，它结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PoolConn</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span>
</span></span><span class=line><span class=cl>   <span class=nx>c</span> <span class=o>*</span><span class=nx>channelPool</span>
</span></span><span class=line><span class=cl>   <span class=nx>unusable</span> <span class=kt>bool</span>     <span class=c1>// if unusable is true, the conn should be closed</span>
</span></span><span class=line><span class=cl>   <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>t</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>  <span class=c1>// connection idle time</span>
</span></span><span class=line><span class=cl>   <span class=nx>dialTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span> <span class=c1>// connection timeout duration</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到它是对原生连接 net.Conn 进行了修饰。它修饰了 net.Conn 的 Read、Write、Close 方法。Read 和 Write 上面也提到过，读失败会将 unusable 这个标志置为 true，表示连接异常，不可用了。写失败也会这样。同时在 Close 之前会判断 unusable 这个标志位，发现连接健康才会扔回池子里进行复用。</p><h3 id=4连接何时失效何时关闭>4、连接何时失效、何时关闭</h3><p>在解决问题 1、2、3 的过程中，我们发现，其实问题 4 已经被解决了。连接在失效或者被闲置过久则关闭。</p><p>连接在读写失败或者发现对端关闭的时候失效，即将 unusable 置为 true，表示连接异常、不可用。</p><h3 id=5如何实现并发安全>5、如何实现并发安全</h3><p>由于我们是全局使用一个连接池对象来管理连接。那么这个连接池对象是所有协程共用的。这样就会牵涉到并发安全的问题。那么我们如何去实现并发安全呢？在 go 里面实现并发安全其实也比较简单，我们主要使用到互斥锁和并发安全的工具 sync.Map</p><p>（1）全局连接池对象 pool</p><p>全局连接池对象是所有协程共用的。它主要是实现对所有子连接池的统一管理，这里为了保证并发安全，通过一个并发安全的工具 sync.Map 来进行实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pool</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>opts</span> <span class=o>*</span><span class=nx>Options</span>
</span></span><span class=line><span class=cl>   <span class=nx>conns</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>（2）子连接池 channelPool</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>channelPool</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span>
</span></span><span class=line><span class=cl>   <span class=nx>initialCap</span> <span class=kt>int</span>  <span class=c1>// initial capacity</span>
</span></span><span class=line><span class=cl>   <span class=nx>maxCap</span> <span class=kt>int</span>      <span class=c1>// max capacity</span>
</span></span><span class=line><span class=cl>   <span class=nx>maxIdle</span> <span class=kt>int</span>     <span class=c1>// max idle conn number</span>
</span></span><span class=line><span class=cl>   <span class=nx>idleTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>  <span class=c1>// idle timeout</span>
</span></span><span class=line><span class=cl>   <span class=nx>dialTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>  <span class=c1>// dial timeout</span>
</span></span><span class=line><span class=cl>   <span class=nx>Dial</span> <span class=kd>func</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>conns</span> <span class=kd>chan</span> <span class=o>*</span><span class=nx>PoolConn</span>
</span></span><span class=line><span class=cl>   <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>子连接池 pool 实现对某类 address 的 server 连接管理。这里主要是使用了互斥锁 sync.Mutex 来保证并发安全。所有的写操作都会进行加锁。</p><p>（3）具体的连接类 PoolConn</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PoolConn</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span>
</span></span><span class=line><span class=cl>   <span class=nx>c</span> <span class=o>*</span><span class=nx>channelPool</span>
</span></span><span class=line><span class=cl>   <span class=nx>unusable</span> <span class=kt>bool</span>     <span class=c1>// if unusable is true, the conn should be closed</span>
</span></span><span class=line><span class=cl>   <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>   <span class=nx>t</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>  <span class=c1>// connection idle time</span>
</span></span><span class=line><span class=cl>   <span class=nx>dialTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span> <span class=c1>// connection timeout duration</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>PoolConn 通过装饰者模式对原生连接 net.Conn 进行了修饰。这里也是通过互斥锁来保证并发安全，只不过这里粒度更细，用了读写锁 sync.RWMutex。</p><p>更多细节可以参考 <a href=https://github.com/lubanproj/gorpc/tree/master/pool/connpool>pool</a></p><h3 id=小结>小结</h3><p>本章主要介绍了连接池 pool 的实现。包括对连接的管理、连接的创建和销毁、连接的复用、连接失效的健康检查以及如何实现并发安全等。本章内容较多，大家可以好好再详细梳理一下。</p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/go-rpc/log-component/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第十章：日志模块实现</span>
</a><a href=https://diu.life/lessons/go-rpc/interceptor/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第十二章：拦截器实现</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2025 <a href=https://diu.life/>丢哥</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>