<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第十八章：分布式链路追踪原理及选型 | 丢哥</title><meta name=keywords content><meta name=description content="一、什么是分布式链路追踪？
现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/go-rpc/tracing-selection/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/go-rpc/tracing-selection/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2499390968830075" crossorigin=anonymous></script><meta property="og:url" content="https://diu.life/lessons/go-rpc/tracing-selection/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第十八章：分布式链路追踪原理及选型"><meta property="og:description" content="一、什么是分布式链路追踪？ 现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2020-02-18T00:00:00+08:00"><meta property="article:modified_time" content="2020-02-18T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第十八章：分布式链路追踪原理及选型"><meta name=twitter:description content="一、什么是分布式链路追踪？
现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"从 0 到 1 开发一款高性能 RPC 框架","item":"https://diu.life/lessons/go-rpc/"},{"@type":"ListItem","position":3,"name":"第十八章：分布式链路追踪原理及选型","item":"https://diu.life/lessons/go-rpc/tracing-selection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第十八章：分布式链路追踪原理及选型","name":"第十八章：分布式链路追踪原理及选型","description":"一、什么是分布式链路追踪？ 现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。\n","keywords":[],"articleBody":"一、什么是分布式链路追踪？ 现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。\n分布式链路追踪技术通过在请求的源头进行标记，将这个标记顺着请求链路层层透传，从而得到整个调用链路的拓扑图，从而为分布式应用的开发者提供完整的调用链路还原、调用请求量统计、链路拓扑和应用依赖分析等工具。\n二、opentracing 规范 分布式链路追踪技术的应用，最早起源于 Google 的一篇论文 Dapper, a Large-Scale Distributed Systems Tracing Infrastructure。这篇论文介绍了分布式链路追踪的原理和一些基础概念，后来这项技术得到各大厂广泛运用。比如 Twitter 的 zipkin、阿里的鹰眼、腾讯的天机阁、大众点评的 cat 等。由于不同的平台有不同的业务场景和实现标准，导致出现了各种各样的链路追踪的规范。为了解决这个问题，于是业内出现了一套统一规范 —— opentracing。opentracing 只定义分布式链路追踪的标准，并没有定义具体实现方式。下面我们对 opentracing 的规范进行简单介绍。\n1、核心概念 用户 │ ▼ 服务 A （前端系统） ├────▶ 服务 B （中间层，处理后直接返回给 A） │ └────▶ 服务 C （中间层） ├────▶ 服务 D （后端系统） └────▶ 服务 E （后端系统） 我们先分析一个比较基本的服务调用链路图，如上图， A~E 分别表示五个服务，用户发起一次 X 请求到服务 A，然后 A 分别发送 RPC 请求到中间层 B 和 C，B 处理请求后返回，C 还要发起两个 RPC 请求到后端系统 D 和 E。\nTrace\n我们把上面一个完整的调用回路称为 trace。一个 trace 代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个 trace 可以认为是多个 span 的有向无环图（DAG）。\n在一个完整调用回路中，一次请求需要经过多个系统处理完成，并且追踪系统像是内嵌在 RPC 调用链上的树形结构，然而，我们的核心数据模型不只局限于特定的 RPC 框架，我们还能追踪其他行为，例如外界的 HTTP 请求，和外部对 Kafka 服务器的调用等。从形式上看，针对 trace 我们使用一个树形结构来记录请求之间的关系（父子关系、先后顺序等）。\nSpan\n一个 span 代表系统中具有开始时间和执行时长的逻辑运行单元。span 之间通过嵌套或者顺序排列建立逻辑因果关系。\n拿上图来说，一个 tracer 过程中，A、B、C、D、E 各 span 的关系可能如下：\n[Span A] ←←←(the root span) | +------+------+ | | [Span B] [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf) | +---+-------+ | | [Span D] [Span E] \u003e\u003e\u003e [其他平级 Span] opentracing 规范约定，span 之间有两种关系，一种是 ChildOf ，也就是父子关系，如上图的 A 和 B、C ，C 和 D、E 就是父子关系。另一种是 FollowsFrom，这是一种平级关系 ，例如上图中的 B 和 C，E 和 F 等。\nSpanContext\n每个 Span 必须提供访问的 SpanContext，SpanContext 一般用来保存需要传递到下游的服务的一些信息。比如 TraceID、SpanID、ParentSpanID 等，SpanContext 还可以用来封装 Baggage （存储在 SpanContext 中的一个键值对集合）\n更多的概念可以参考：opentracing 英文版， opentracing 翻译版\n三、技术选型 社区内支持 opentracing 规范的比较著名的开源项目有 jaeger、zipkin、appdash 、cat 等。\njaeger： go 语言开发，入手较为困难，系统侵入性一般，数据维度比较丰富，但是入手比较困难。 appdash：go 语言开发，适合于开发小型的 trace 系统，主要依赖内存，不适合大规模使用。 zipkin，java 语言开发，github 很活跃，系统倾入性强，扩展性高，也有很多大厂使用 cat，java 语言开发，github 不活跃，已不太更新了。 由于我们的框架使用 go 语言实现，所以我们也主要考虑同样使用 go 开发的 jaeger 和 appdash，由于 appdash 比较依赖内存，不适合大规模使用，所以我们最终选择了 jaeger。\n四、jaeger 简单介绍 jaeger 是遵循 opentracing 规范的，所以上面介绍的 opentracing 的相关核心概念 jaeger 中也同样适用，哲理就不赘述了。jaeger 的一些使用方法可以详细参考官方文档 jaeger\n这里我们简单介绍下 jaeger 的架构，如下图：\nclient 将 Span 数据上报到 agent，通过 agent 将数据发送到 collector 进行收集。collector 收集 agent 上报的数据之后，通过 kafka 消息队列，通过 flink 集群将数据汇总到 DB，UI 通过查询 DB 中的数据来进行链路图的展示。\njaeger demo\njaeger 官方提供了一个集成了所有服务的 docker 镜像，运行：\ndocker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ -p 9411:9411 \\ jaegertracing/all-in-one:1.17 然后在浏览器访问 http://localhost:16686 即可看到 jaeger 的 UI，如下：\n小结 本章主要介绍了分布式链路追踪的原理、opentracing 的核心概念和 jaeger 的简单实用，下一章我们将会介绍代码实现\n","wordCount":"1981","inLanguage":"zh","datePublished":"2020-02-18T00:00:00+08:00","dateModified":"2020-02-18T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/go-rpc/tracing-selection/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li><li><a href=https://diu.life/privacy-policy/ title=隐私政策><span>隐私政策</span></a></li><li><a href=https://diu.life/terms-of-service/ title=服务条款><span>服务条款</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Go-Rpc 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/what-is-rpc/ class=chapter-link><span class=chapter-title>第一章：RPC 原理</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/rpc-framework-overview/ class=chapter-link><span class=chapter-title>第二章：RPC 框架概览</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-server/ class=chapter-link><span class=chapter-title>第三章：框架搭建 —— server</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-client/ class=chapter-link><span class=chapter-title>第四章：框架搭建 —— client</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/build-transport/ class=chapter-link><span class=chapter-title>第五章：框架搭建 —— transport</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/context-timeout/ class=chapter-link><span class=chapter-title>第六章：超时机制</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/custom-protocol/ class=chapter-link><span class=chapter-title>第七章：自定义协议实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/codec/ class=chapter-link><span class=chapter-title>第八章：协议编解码实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/marshal-and-unmarshal/ class=chapter-link><span class=chapter-title>第九章：序列化实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/log-component/ class=chapter-link><span class=chapter-title>第十章：日志模块实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/connection-pool/ class=chapter-link><span class=chapter-title>第十一章：连接池实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/interceptor/ class=chapter-link><span class=chapter-title>第十二章：拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/component-interface/ class=chapter-link><span class=chapter-title>第十三章：组件可插拔实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/plugin/ class=chapter-link><span class=chapter-title>第十四章：插件体系实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-selection/ class=chapter-link><span class=chapter-title>第十五章：服务发现原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/service-discovery-implementation/ class=chapter-link><span class=chapter-title>第十六章：服务发现实现 —— consul</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/load-balance-implementation/ class=chapter-link><span class=chapter-title>第十七章：负载均衡实现</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/go-rpc/tracing-selection/ class=chapter-link><span class=chapter-title>第十八章：分布式链路追踪原理及选型</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/tracing-implementation/ class=chapter-link><span class=chapter-title>第十九章：分布式链路追踪实现 —— jaeger</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/auth/ class=chapter-link><span class=chapter-title>第二十章：认证鉴权实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/code-generation/ class=chapter-link><span class=chapter-title>第二十一章：代码生成工具实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-test/ class=chapter-link><span class=chapter-title>第二十二章：框架性能测试</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/performance-optimization/ class=chapter-link><span class=chapter-title>第二十三章：框架性能优化</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/go-rpc/summary/ class=chapter-link><span class=chapter-title>第二十四章：总结与展望</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第十八章：分布式链路追踪原理及选型</h1><div class=post-meta><time datetime=2020-02-18T00:00:00+08:00>2020-02-18</time></div></header><div class=post-content><h3 id=一什么是分布式链路追踪>一、什么是分布式链路追踪？</h3><p>现代微服务系统中，一套复杂的分布式 Web 系统中，客户端的一次请求操作，可能需要经过系统中多个模块、多个中间件、多台机器的相互协作才能完成，并且这一系列调用请求中，有些是串行处理的，有些是并发执行的，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何呢？为了解决这个问题，分布式链路追踪这个概念应运而生。</p><p>分布式链路追踪技术通过在请求的源头进行标记，将这个标记顺着请求链路层层透传，从而得到整个调用链路的拓扑图，从而为分布式应用的开发者提供完整的调用链路还原、调用请求量统计、链路拓扑和应用依赖分析等工具。</p><h3 id=二opentracing-规范>二、opentracing 规范</h3><p>分布式链路追踪技术的应用，最早起源于 Google 的一篇论文 <a href=https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a>。这篇论文介绍了分布式链路追踪的原理和一些基础概念，后来这项技术得到各大厂广泛运用。比如 Twitter 的 zipkin、阿里的鹰眼、腾讯的天机阁、大众点评的 cat 等。由于不同的平台有不同的业务场景和实现标准，导致出现了各种各样的链路追踪的规范。为了解决这个问题，于是业内出现了一套统一规范 —— opentracing。opentracing 只定义分布式链路追踪的标准，并没有定义具体实现方式。下面我们对 opentracing 的规范进行简单介绍。</p><h4 id=1核心概念>1、核心概念</h4><pre tabindex=0><code>用户
 │
 ▼
服务 A （前端系统）
 ├────▶ 服务 B （中间层，处理后直接返回给 A）
 │
 └────▶ 服务 C （中间层）
           ├────▶ 服务 D （后端系统）
           └────▶ 服务 E （后端系统）
</code></pre><p>我们先分析一个比较基本的服务调用链路图，如上图， A~E 分别表示五个服务，用户发起一次 X 请求到服务 A，然后 A 分别发送 RPC 请求到中间层 B 和 C，B 处理请求后返回，C 还要发起两个 RPC 请求到后端系统 D 和 E。</p><p><strong>Trace</strong></p><p>我们把上面一个完整的调用回路称为 trace。一个 trace 代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个 trace 可以认为是多个 span 的有向无环图（DAG）。</p><p>在一个完整调用回路中，一次请求需要经过多个系统处理完成，并且追踪系统像是内嵌在 RPC 调用链上的树形结构，然而，我们的核心数据模型不只局限于特定的 RPC 框架，我们还能追踪其他行为，例如外界的 HTTP 请求，和外部对 Kafka 服务器的调用等。从形式上看，针对 trace 我们使用一个树形结构来记录请求之间的关系（父子关系、先后顺序等）。</p><p><strong>Span</strong></p><p>一个 span 代表系统中具有开始时间和执行时长的逻辑运行单元。span 之间通过嵌套或者顺序排列建立逻辑因果关系。</p><p>拿上图来说，一个 tracer 过程中，A、B、C、D、E 各 span 的关系可能如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>         <span class=p>[</span><span class=nx>Span</span> <span class=nx>A</span><span class=p>]</span>  <span class=err>←←←</span><span class=p>(</span><span class=nx>the</span> <span class=nx>root</span> <span class=nx>span</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>|</span>
</span></span><span class=line><span class=cl>     <span class=o>+------+------+</span>
</span></span><span class=line><span class=cl>     <span class=p>|</span>             <span class=p>|</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=nx>Span</span> <span class=nx>B</span><span class=p>]</span>      <span class=p>[</span><span class=nx>Span</span> <span class=nx>C</span><span class=p>]</span> <span class=err>←←←</span><span class=p>(</span><span class=nx>Span</span> <span class=nx>C</span> <span class=nx>是</span> <span class=nx>Span</span> <span class=nx>A</span> <span class=nx>的孩子节点</span><span class=p>,</span> <span class=nx>ChildOf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                   <span class=p>|</span>
</span></span><span class=line><span class=cl>               <span class=o>+---+-------+</span>
</span></span><span class=line><span class=cl>               <span class=p>|</span>           <span class=p>|</span>
</span></span><span class=line><span class=cl>           <span class=p>[</span><span class=nx>Span</span> <span class=nx>D</span><span class=p>]</span>    <span class=p>[</span><span class=nx>Span</span> <span class=nx>E</span><span class=p>]</span> <span class=o>&gt;&gt;</span><span class=p>&gt;</span> <span class=p>[</span><span class=nx>其他平级</span> <span class=nx>Span</span><span class=p>]</span>
</span></span></code></pre></div><p>opentracing 规范约定，span 之间有两种关系，一种是 ChildOf ，也就是父子关系，如上图的 A 和 B、C ，C 和 D、E 就是父子关系。另一种是 FollowsFrom，这是一种平级关系 ，例如上图中的 B 和 C，E 和 F 等。</p><p><strong>SpanContext</strong></p><p>每个 Span 必须提供访问的 SpanContext，SpanContext 一般用来保存需要传递到下游的服务的一些信息。比如 TraceID、SpanID、ParentSpanID 等，SpanContext 还可以用来封装 Baggage （存储在 SpanContext 中的一个键值对集合）</p><p>更多的概念可以参考：<a href=https://opentracing.io/>opentracing 英文版</a>， <a href=https://wu-sheng.gitbooks.io/opentracing-io/content/pages/spec.html>opentracing 翻译版</a></p><h3 id=三技术选型>三、技术选型</h3><p>社区内支持 opentracing 规范的比较著名的开源项目有 jaeger、zipkin、appdash 、cat 等。</p><ul><li>jaeger： go 语言开发，入手较为困难，系统侵入性一般，数据维度比较丰富，但是入手比较困难。</li><li>appdash：go 语言开发，适合于开发小型的 trace 系统，主要依赖内存，不适合大规模使用。</li><li>zipkin，java 语言开发，github 很活跃，系统倾入性强，扩展性高，也有很多大厂使用</li><li>cat，java 语言开发，github 不活跃，已不太更新了。</li></ul><p>由于我们的框架使用 go 语言实现，所以我们也主要考虑同样使用 go 开发的 jaeger 和 appdash，由于 appdash 比较依赖内存，不适合大规模使用，所以我们最终选择了 jaeger。</p><h3 id=四jaeger-简单介绍>四、jaeger 简单介绍</h3><p>jaeger 是遵循 opentracing 规范的，所以上面介绍的 opentracing 的相关核心概念 jaeger 中也同样适用，哲理就不赘述了。jaeger 的一些使用方法可以详细参考官方文档 <a href=https://www.jaegertracing.io/>jaeger</a></p><p>这里我们简单介绍下 jaeger 的架构，如下图：</p><p><img alt=img loading=lazy src=/images/go-rpc/18-1.jpg></p><p>client 将 Span 数据上报到 agent，通过 agent 将数据发送到 collector 进行收集。collector 收集 agent 上报的数据之后，通过 kafka 消息队列，通过 flink 集群将数据汇总到 DB，UI 通过查询 DB 中的数据来进行链路图的展示。</p><p><strong>jaeger demo</strong></p><p>jaeger 官方提供了一个集成了所有服务的 docker 镜像，运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d --name jaeger <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -e <span class=nv>COLLECTOR_ZIPKIN_HTTP_PORT</span><span class=o>=</span><span class=m>9411</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 5775:5775/udp <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 6831:6831/udp <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 6832:6832/udp <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 5778:5778 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 16686:16686 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 14268:14268 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 14250:14250 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -p 9411:9411 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  jaegertracing/all-in-one:1.17
</span></span></code></pre></div><p>然后在浏览器访问 <a href=http://localhost:16686>http://localhost:16686</a> 即可看到 jaeger 的 UI，如下：</p><p><img alt=img loading=lazy src=/images/go-rpc/18-2.jpg></p><h3 id=小结>小结</h3><p>本章主要介绍了分布式链路追踪的原理、opentracing 的核心概念和 jaeger 的简单实用，下一章我们将会介绍代码实现</p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/go-rpc/load-balance-implementation/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第十七章：负载均衡实现</span>
</a><a href=https://diu.life/lessons/go-rpc/tracing-implementation/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第十九章：分布式链路追踪实现 —— jaeger</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2021 丢哥 all rights reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>