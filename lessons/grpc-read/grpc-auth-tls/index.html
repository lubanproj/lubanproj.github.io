<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第七章：grpc 认证鉴权——tls认证 | 丢哥</title><meta name=keywords content><meta name=description content="grpc 认证鉴权
在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。
1、单体模式下的认证鉴权
在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/grpc-read/grpc-auth-tls/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/grpc-read/grpc-auth-tls/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://diu.life/lessons/grpc-read/grpc-auth-tls/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第七章：grpc 认证鉴权——tls认证"><meta property="og:description" content="grpc 认证鉴权 在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。
1、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2019-11-07T00:00:00+08:00"><meta property="article:modified_time" content="2019-11-07T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第七章：grpc 认证鉴权——tls认证"><meta name=twitter:description content="grpc 认证鉴权
在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。
1、单体模式下的认证鉴权
在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"gRPC 源码阅读","item":"https://diu.life/lessons/grpc-read/"},{"@type":"ListItem","position":3,"name":"第七章：grpc 认证鉴权——tls认证","item":"https://diu.life/lessons/grpc-read/grpc-auth-tls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第七章：grpc 认证鉴权——tls认证","name":"第七章：grpc 认证鉴权——tls认证","description":"grpc 认证鉴权 在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。\n1、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。\n","keywords":[],"articleBody":"grpc 认证鉴权 在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。\n1、单体模式下的认证鉴权 在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。\n客户端访问服务端时，服务端一般会用一个拦截器拦截请求，取出 session id，假如 id 合法，则可判断客户端登陆。然后查询用户的权限表，判断用户是否具有执行某次操作的权限。\n2、微服务模式下的认证鉴权 在微服务模式下，一个整体的应用可能被拆分为多个微服务，之前只有一个服务端，现在会存在多个服务端。对于客户端的单个请求，为保证安全，需要跟每个微服务都要重复上面的过程。这种模式每个微服务都要去实现相同的校验逻辑，肯定是非常冗余的。\n用户身份认证 为了避免每个服务端都进行重复认证，采用一个服务进行统一认证。所以考虑一个单点登录的方案，用户只需要登录一次，就可以访问所有微服务。一般在 api 的 gateway 层提供对外服务的入口，所以可以在 api gateway 层提供统一的用户认证。\n用户状态保持 由于 http 是一个无状态的协议，前面说到了单体模式下通过 cookie 保存用户状态， cookie 一般存储于浏览器中，用来保存用户的信息。但是 cookie 是有状态的。客户端和服务端在一次会话期间都需要维护 cookie 或者 sessionId，在微服务环境下，我们期望服务的认证是无状态的。所以我们一般采用 token 认证的方式，而非 cookie。\ntoken 由服务端用自己的密钥加密生成，在客户端登录或者完成信息校验时返回给客户端，客户端认证成功后每次向服务端发送请求带上 token，服务端根据密钥进行解密，从而校验 token 的合法，假如合法则认证通过。token 这种方式的校验不需要服务端保存会话状态。方便服务扩展\n3、grpc 认证鉴权 grpc-go 官方对于认证鉴权的介绍如下：https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md\n通过官方介绍可知， grpc-go 认证鉴权是通过 tls + oauth2 实现的。这里不对 tls 和 oauth2 进行详细介绍，假如有不清楚的可以参考阮一峰老师的教程，介绍得比较清楚\ntls ：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html oauth2 ：http://www.ruanyifeng.com/blog/2019/04/oauth_design.html\n下面我们就来具体看看 grpc-go 是如何实现认证鉴权的\ngrpc-go 官方 doc 说了这里关于 auth 的部分有 demo 放在 examples 目录下的 features 目录下。但是 demo 没有包括证书生成的步骤，这里我们自建一个 demo，从生成证书开始一步步进行 grpc 的认证讲解。\n我们先创建一个文件夹 helloauth，然后把之前examples 目录下 helloworld demo 中的 client 和 server 的 go 文件全部 copy 过来，先执行 go mod init helloauth 来生成 go.mod 文件。由于 google.golang.org 被墙，所以执行 go mod edit -replace=google.golang.org/grpc=github.com/grpc/grpc-go@latest， 接着 注意把 替换成 pb “google.golang.org/grpc/examples/helloworld/helloworld” 替换成 pb “helloauth/helloworld” 来引用我们新生成的 pb 文件\n生成证书 生成私钥\nopenssl ecparam -genkey -name secp384r1 -out server.key 使用私钥生成证书\nopenssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650 填写信息（注意 Common Name 要填写服务名）\nCountry Name (2 letter code) []: State or Province Name (full name) []: Locality Name (eg, city) []: Organization Name (eg, company) []: Organizational Unit Name (eg, section) []: Common Name (eg, fully qualified host name) []:helloauth Email Address []: 生成完毕后，将证书文件放到 keys 目录下，整个项目目录结构如下： 使用证书进行 TLS 通信认证 我们之前的 helloworld demo 中，client 在创建 DialContext 指定非安全模式通信，如下：\nconn, err := grpc.Dial(address, grpc.WithInsecure()) 这种模式下，client 和 server 都不会进行通信认证，其实是不安全的。下面我们来看看安全模式下应该如何通信\nserver package main import ( \"context\" \"log\" \"net\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" pb \"google.golang.org/grpc/examples/helloworld/helloworld\" ) const ( port = \":50051\" ) // server is used to implement helloworld.GreeterServer. type server struct{} // SayHello implements helloworld.GreeterServer func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) { log.Printf(\"Received: %v\", in.Name) return \u0026pb.HelloReply{Message: \"Hello \" + in.Name}, nil } func main() { c, err := credentials.NewServerTLSFromFile(\"../keys/server.pem\", \"../keys/server.key\") if err != nil { log.Fatalf(\"credentials.NewServerTLSFromFile err: %v\", err) } lis, err := net.Listen(\"tcp\", port) if err != nil { log.Fatalf(\"failed to listen: %v\", err) } s := grpc.NewServer(grpc.Creds(c)) pb.RegisterGreeterServer(s, \u0026server{}) if err := s.Serve(lis); err != nil { log.Fatalf(\"failed to serve: %v\", err) } } client package main import ( \"context\" \"log\" \"os\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" pb \"helloauth/helloworld\" ) const ( address = \"localhost:50051\" defaultName = \"world\" ) func main() { cred, err := credentials.NewClientTLSFromFile(\"../keys/server.pem\", \"helloauth\") if err != nil { log.Fatalf(\"credentials.NewClientTLSFromFile err: %v\", err) } // Set up a connection to the server. conn, err := grpc.Dial(address, grpc.WithTransportCredentials(cred)) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := pb.NewGreeterClient(conn) // Contact the server and print out its response. name := defaultName if len(os.Args) \u003e 1 { name = os.Args[1] } ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() r, err := c.SayHello(ctx, \u0026pb.HelloRequest{Name: name}) if err != nil { log.Fatalf(\"could not greet: %v\", err) } log.Printf(\"Greeting: %s\", r.Message) } 这里的代码已经上传 github 了，详见：https://github.com/diubrother/helloauth\n4、grpc 认证鉴权源码解读 server 先来看 server 端，server 端根据 server 的公钥和私钥生成了一个 TransportCredentials ，如下：\nc, err := credentials.NewServerTLSFromFile(\"../keys/server.pem\", \"../keys/server.key\") func NewServerTLSFromFile(certFile, keyFile string) (TransportCredentials, error) { cert, err := tls.LoadX509KeyPair(certFile, keyFile) if err != nil { return nil, err } return NewTLS(\u0026tls.Config{Certificates: []tls.Certificate{cert}}), nil } 看一下 NewTLS 这个方法，他其实就返回了一个 tlsCreds 的结构体，这个结构体实现了 TransportCredentials 这个接口，包括 ClientHandshake 和 ServerHandshake 。\nfunc NewTLS(c *tls.Config) TransportCredentials { tc := \u0026tlsCreds{cloneTLSConfig(c)} tc.config.NextProtos = appendH2ToNextProtos(tc.config.NextProtos) return tc } 来看一下服务端握手的方法 ServerHandshake，可以发现其底层还是调用 go 的 tls 包去实现 tls 认证鉴权。\nfunc (c *tlsCreds) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) { conn := tls.Server(rawConn, c.config) if err := conn.Handshake(); err != nil { return nil, nil, err } return internal.WrapSyscallConn(rawConn, conn), TLSInfo{conn.ConnectionState()}, nil } client 和 server 端类似，client 端也是通过公钥和服务名先创建一个 TransportCredentials\ncred, err := credentials.NewClientTLSFromFile(\"../keys/server.pem\", \"helloauth\") 看一下 NewClientTLSFromFile 这个方法，发现它也是调用了相同的 NewTLS 方法返回了一个 tlsCreds 结构体，跟 server 简直一模一样。\nfunc NewTLS(c *tls.Config) TransportCredentials { tc := \u0026tlsCreds{cloneTLSConfig(c)} tc.config.NextProtos = appendH2ToNextProtos(tc.config.NextProtos) return tc } 接下来在创建客户端连接时，将 tlsCreds 这个结构体传了进去。\nconn, err := grpc.Dial(address, grpc.WithTransportCredentials(cred)) Dial —— \u003e DialContext 方法中有这么一段代码，将我们传入的 serverName 也就是 “helloauth\" 赋值给了 clientConn 的 authority 这个字段。\ncreds := cc.dopts.copts.TransportCredentials if creds != nil \u0026\u0026 creds.Info().ServerName != \"\" { cc.authority = creds.Info().ServerName } else if cc.dopts.insecure \u0026\u0026 cc.dopts.authority != \"\" { cc.authority = cc.dopts.authority } else { // Use endpoint from \"scheme://authority/endpoint\" as the default // authority for ClientConn. cc.authority = cc.parsedTarget.Endpoint } 认证过程 client 那什么时候开始认证呢？先来说说 client。\nclient 的认证其实是在调用 connect 方法的时候，在之前讲述负载均衡时降到了，在 acBalancerWrapper 里面有一个 UpdateAddresses 方法，调用 ac.connect() ——\u003e ac.resetTransport() ——\u003e ac.tryAllAddrs ——\u003e ac.createTransport ——\u003e transport.NewClientTransport ——\u003e newHTTP2Client 方法时，有这么一段代码：\ntransportCreds := opts.TransportCredentials perRPCCreds := opts.PerRPCCredentials\nif b := opts.CredsBundle; b != nil { if t := b.TransportCredentials(); t != nil { transportCreds = t } if t := b.PerRPCCredentials(); t != nil { perRPCCreds = append(perRPCCreds, t) } } if transportCreds != nil { scheme = \"https\" conn, authInfo, err = transportCreds.ClientHandshake(connectCtx, addr.Authority, conn) if err != nil { return nil, connectionErrorf(isTemporary(err), err, \"transport: authentication handshake failed: %v\", err) } isSecure = true } 这里即调用了tlsCreds 的 ClientHandshake 方法进行握手，实现客户端的认证。\nserver 再来说说 server\nserver 的认证其实是在调用 Serve ——\u003e handleRawConn ——\u003e useTransportAuthenticator 方法，调用了 s.opts.creds.ServerHandshake(rawConn) 方法，其底层也是调用 tlsCreds ServerHandshake 方法进行服务端握手。\nfunc (s *Server) useTransportAuthenticator(rawConn net.Conn) (net.Conn, credentials.AuthInfo, error) { if s.opts.creds == nil { return rawConn, nil, nil } return s.opts.creds.ServerHandshake(rawConn) } ","wordCount":"2615","inLanguage":"zh","datePublished":"2019-11-07T00:00:00+08:00","dateModified":"2019-11-07T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/grpc-read/grpc-auth-tls/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Grpc-Read 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-concepts-http2/ class=chapter-link><span class=chapter-title>第一章：grpc concepts & http2</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world/ class=chapter-link><span class=chapter-title>第二章：grpc hello world</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/ class=chapter-link><span class=chapter-title>第三章：grpc hello world server 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/ class=chapter-link><span class=chapter-title>第四章：grpc hello world client 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-service-discovery/ class=chapter-link><span class=chapter-title>第五章：grpc 服务发现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-load-balancing/ class=chapter-link><span class=chapter-title>第六章：grpc 负载均衡</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/grpc-read/grpc-auth-tls/ class=chapter-link><span class=chapter-title>第七章：grpc 认证鉴权——tls认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-oauth2/ class=chapter-link><span class=chapter-title>第八章：grpc 认证鉴权——oauth2认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/ class=chapter-link><span class=chapter-title>第九章：grpc 拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/ class=chapter-link><span class=chapter-title>第十章：grpc 协议编解码器</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/ class=chapter-link><span class=chapter-title>第十一章：grpc 协议解包过程全剖析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-data-flow/ class=chapter-link><span class=chapter-title>第十二章：grpc 数据流转</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第七章：grpc 认证鉴权——tls认证</h1><div class=post-meta><time datetime=2019-11-07T00:00:00+08:00>2019-11-07</time></div></header><div class=post-content><h2 id=grpc-认证鉴权>grpc 认证鉴权</h2><p>在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。</p><h3 id=1单体模式下的认证鉴权>1、单体模式下的认证鉴权</h3><p>在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。</p><p>客户端访问服务端时，服务端一般会用一个拦截器拦截请求，取出 session id，假如 id 合法，则可判断客户端登陆。然后查询用户的权限表，判断用户是否具有执行某次操作的权限。</p><h3 id=2微服务模式下的认证鉴权>2、微服务模式下的认证鉴权</h3><p>在微服务模式下，一个整体的应用可能被拆分为多个微服务，之前只有一个服务端，现在会存在多个服务端。对于客户端的单个请求，为保证安全，需要跟每个微服务都要重复上面的过程。这种模式每个微服务都要去实现相同的校验逻辑，肯定是非常冗余的。</p><h4 id=用户身份认证>用户身份认证</h4><p>为了避免每个服务端都进行重复认证，采用一个服务进行统一认证。所以考虑一个单点登录的方案，用户只需要登录一次，就可以访问所有微服务。一般在 api 的 gateway 层提供对外服务的入口，所以可以在 api gateway 层提供统一的用户认证。</p><h4 id=用户状态保持>用户状态保持</h4><p>由于 http 是一个无状态的协议，前面说到了单体模式下通过 cookie 保存用户状态， cookie 一般存储于浏览器中，用来保存用户的信息。但是 cookie 是有状态的。客户端和服务端在一次会话期间都需要维护 cookie 或者 sessionId，在微服务环境下，我们期望服务的认证是无状态的。所以我们一般采用 token 认证的方式，而非 cookie。</p><p>token 由服务端用自己的密钥加密生成，在客户端登录或者完成信息校验时返回给客户端，客户端认证成功后每次向服务端发送请求带上 token，服务端根据密钥进行解密，从而校验 token 的合法，假如合法则认证通过。token 这种方式的校验不需要服务端保存会话状态。方便服务扩展</p><h3 id=3grpc-认证鉴权>3、grpc 认证鉴权</h3><p>grpc-go 官方对于认证鉴权的介绍如下：https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md</p><p>通过官方介绍可知， grpc-go 认证鉴权是通过 tls + oauth2 实现的。这里不对 tls 和 oauth2 进行详细介绍，假如有不清楚的可以参考阮一峰老师的教程，介绍得比较清楚</p><p>tls ：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
oauth2 ：http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</p><p>下面我们就来具体看看 grpc-go 是如何实现认证鉴权的</p><p>grpc-go 官方 doc 说了这里关于 auth 的部分有 demo 放在 examples 目录下的 features 目录下。但是 demo 没有包括证书生成的步骤，这里我们自建一个 demo，从生成证书开始一步步进行 grpc 的认证讲解。</p><p>我们先创建一个文件夹 helloauth，然后把之前examples 目录下 helloworld demo 中的 client 和 server 的 go 文件全部 copy 过来，先执行 go mod init helloauth 来生成 go.mod 文件。由于 google.golang.org 被墙，所以执行 go mod edit -replace=google.golang.org/grpc=github.com/grpc/grpc-go@latest， 接着
注意把 替换成 pb &ldquo;google.golang.org/grpc/examples/helloworld/helloworld&rdquo; 替换成 pb &ldquo;helloauth/helloworld&rdquo; 来引用我们新生成的 pb 文件</p><h4 id=生成证书>生成证书</h4><p>生成私钥</p><pre><code>openssl ecparam -genkey -name secp384r1 -out server.key
</code></pre><p>使用私钥生成证书</p><pre><code>openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
</code></pre><p>填写信息（注意 Common Name 要填写服务名）</p><pre><code>Country Name (2 letter code) []:
State or Province Name (full name) []:
Locality Name (eg, city) []:
Organization Name (eg, company) []:
Organizational Unit Name (eg, section) []:
Common Name (eg, fully qualified host name) []:helloauth
Email Address []:
</code></pre><p>生成完毕后，将证书文件放到 keys 目录下，整个项目目录结构如下：
<img alt="grpc auth tls" loading=lazy src=/images/grpc-read/7-1.jpg></p><h4 id=使用证书进行-tls-通信认证>使用证书进行 TLS 通信认证</h4><p>我们之前的 helloworld demo 中，client 在创建 DialContext 指定非安全模式通信，如下：</p><pre><code>	conn, err := grpc.Dial(address, grpc.WithInsecure())
</code></pre><p>这种模式下，client 和 server 都不会进行通信认证，其实是不安全的。下面我们来看看安全模式下应该如何通信</p><h4 id=server>server</h4><pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;

	pb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;
)

const (
	port = &quot;:50051&quot;
)

// server is used to implement helloworld.GreeterServer.
type server struct{}

// SayHello implements helloworld.GreeterServer
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
	log.Printf(&quot;Received: %v&quot;, in.Name)
	return &amp;pb.HelloReply{Message: &quot;Hello &quot; + in.Name}, nil
}

func main() {
	c, err := credentials.NewServerTLSFromFile(&quot;../keys/server.pem&quot;, &quot;../keys/server.key&quot;)
    	if err != nil {
        	log.Fatalf(&quot;credentials.NewServerTLSFromFile err: %v&quot;, err)
    	}

	lis, err := net.Listen(&quot;tcp&quot;, port)
	if err != nil {
		log.Fatalf(&quot;failed to listen: %v&quot;, err)
	}
	s := grpc.NewServer(grpc.Creds(c))
	pb.RegisterGreeterServer(s, &amp;server{})
	if err := s.Serve(lis); err != nil {
		log.Fatalf(&quot;failed to serve: %v&quot;, err)
	}
}
</code></pre><h4 id=client>client</h4><pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;time&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;

	pb &quot;helloauth/helloworld&quot;
)

const (
	address     = &quot;localhost:50051&quot;
	defaultName = &quot;world&quot;
)

func main() {
	cred, err := credentials.NewClientTLSFromFile(&quot;../keys/server.pem&quot;, &quot;helloauth&quot;)
    	if err != nil {
        	log.Fatalf(&quot;credentials.NewClientTLSFromFile err: %v&quot;, err)
    	}

	// Set up a connection to the server.
	conn, err := grpc.Dial(address, grpc.WithTransportCredentials(cred))
	if err != nil {
		log.Fatalf(&quot;did not connect: %v&quot;, err)
	}
	defer conn.Close()
	c := pb.NewGreeterClient(conn)

	// Contact the server and print out its response.
	name := defaultName
	if len(os.Args) &gt; 1 {
		name = os.Args[1]
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := c.SayHello(ctx, &amp;pb.HelloRequest{Name: name})
	if err != nil {
		log.Fatalf(&quot;could not greet: %v&quot;, err)
	}
	log.Printf(&quot;Greeting: %s&quot;, r.Message)
}
</code></pre><p>这里的代码已经上传 github 了，详见：https://github.com/diubrother/helloauth</p><h3 id=4grpc-认证鉴权源码解读>4、grpc 认证鉴权源码解读</h3><h4 id=server-1>server</h4><p>先来看 server 端，server 端根据 server 的公钥和私钥生成了一个 TransportCredentials ，如下：</p><pre><code>c, err := credentials.NewServerTLSFromFile(&quot;../keys/server.pem&quot;, &quot;../keys/server.key&quot;)

func NewServerTLSFromFile(certFile, keyFile string) (TransportCredentials, error) {
	cert, err := tls.LoadX509KeyPair(certFile, keyFile)
	if err != nil {
		return nil, err
	}
	return NewTLS(&amp;tls.Config{Certificates: []tls.Certificate{cert}}), nil
}
</code></pre><p>看一下 NewTLS 这个方法，他其实就返回了一个 tlsCreds 的结构体，这个结构体实现了 TransportCredentials 这个接口，包括 ClientHandshake 和 ServerHandshake 。</p><pre><code>func NewTLS(c *tls.Config) TransportCredentials {
	tc := &amp;tlsCreds{cloneTLSConfig(c)}
	tc.config.NextProtos = appendH2ToNextProtos(tc.config.NextProtos)
	return tc
}
</code></pre><p>来看一下服务端握手的方法 ServerHandshake，可以发现其底层还是调用 go 的 tls 包去实现 tls 认证鉴权。</p><pre><code>func (c *tlsCreds) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) {
	conn := tls.Server(rawConn, c.config)
	if err := conn.Handshake(); err != nil {
		return nil, nil, err
	}
	return internal.WrapSyscallConn(rawConn, conn), TLSInfo{conn.ConnectionState()}, nil
}
</code></pre><h4 id=client-1>client</h4><p>和 server 端类似，client 端也是通过公钥和服务名先创建一个 TransportCredentials</p><pre><code>cred, err := credentials.NewClientTLSFromFile(&quot;../keys/server.pem&quot;, &quot;helloauth&quot;)
</code></pre><p>看一下 NewClientTLSFromFile 这个方法，发现它也是调用了相同的 NewTLS 方法返回了一个 tlsCreds 结构体，跟 server 简直一模一样。</p><pre><code>func NewTLS(c *tls.Config) TransportCredentials {
	tc := &amp;tlsCreds{cloneTLSConfig(c)}
	tc.config.NextProtos = appendH2ToNextProtos(tc.config.NextProtos)
	return tc
}
</code></pre><p>接下来在创建客户端连接时，将 tlsCreds 这个结构体传了进去。</p><pre><code>conn, err := grpc.Dial(address, grpc.WithTransportCredentials(cred))
</code></pre><p>Dial —— > DialContext 方法中有这么一段代码，将我们传入的 serverName 也就是 “helloauth" 赋值给了 clientConn 的 authority 这个字段。</p><pre><code>	creds := cc.dopts.copts.TransportCredentials
	if creds != nil &amp;&amp; creds.Info().ServerName != &quot;&quot; {
		cc.authority = creds.Info().ServerName
	} else if cc.dopts.insecure &amp;&amp; cc.dopts.authority != &quot;&quot; {
		cc.authority = cc.dopts.authority
	} else {
		// Use endpoint from &quot;scheme://authority/endpoint&quot; as the default
		// authority for ClientConn.
		cc.authority = cc.parsedTarget.Endpoint
	}
</code></pre><h4 id=认证过程>认证过程</h4><h4 id=client-2>client</h4><p>那什么时候开始认证呢？先来说说 client。</p><p>client 的认证其实是在调用 connect 方法的时候，在之前讲述负载均衡时降到了，在 acBalancerWrapper 里面有一个 UpdateAddresses 方法，调用 ac.connect() ——> ac.resetTransport() ——> ac.tryAllAddrs ——> ac.createTransport ——> transport.NewClientTransport ——> newHTTP2Client 方法时，有这么一段代码：</p><p>transportCreds := opts.TransportCredentials
perRPCCreds := opts.PerRPCCredentials</p><pre><code>	if b := opts.CredsBundle; b != nil {
		if t := b.TransportCredentials(); t != nil {
			transportCreds = t
		}
		if t := b.PerRPCCredentials(); t != nil {
			perRPCCreds = append(perRPCCreds, t)
		}
	}
	if transportCreds != nil {
		scheme = &quot;https&quot;
		conn, authInfo, err = transportCreds.ClientHandshake(connectCtx, addr.Authority, conn)
		if err != nil {
			return nil, connectionErrorf(isTemporary(err), err, &quot;transport: authentication handshake failed: %v&quot;, err)
		}
		isSecure = true
	}
</code></pre><p>这里即调用了tlsCreds 的 ClientHandshake 方法进行握手，实现客户端的认证。</p><h4 id=server-2>server</h4><p>再来说说 server</p><p>server 的认证其实是在调用 Serve ——> handleRawConn ——> useTransportAuthenticator 方法，调用了 s.opts.creds.ServerHandshake(rawConn) 方法，其底层也是调用 tlsCreds ServerHandshake 方法进行服务端握手。</p><pre><code>func (s *Server) useTransportAuthenticator(rawConn net.Conn) (net.Conn, credentials.AuthInfo, error) {
	if s.opts.creds == nil {
		return rawConn, nil, nil
	}
	return s.opts.creds.ServerHandshake(rawConn)
}
</code></pre></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/grpc-read/grpc-load-balancing/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第六章：grpc 负载均衡</span>
</a><a href=https://diu.life/lessons/grpc-read/grpc-auth-oauth2/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第八章：grpc 认证鉴权——oauth2认证</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2021 丢哥 all rights reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>