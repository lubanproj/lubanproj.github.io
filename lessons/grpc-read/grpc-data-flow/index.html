<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第十二章：grpc 数据流转 | 丢哥</title><meta name=keywords content><meta name=description content="grpc 数据流转
阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 《10 - grpc 协议编解码器》 和 《11 - grpc 协议解包过程全剖析》"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/grpc-read/grpc-data-flow/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/grpc-read/grpc-data-flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2499390968830075" crossorigin=anonymous></script><meta property="og:url" content="https://diu.life/lessons/grpc-read/grpc-data-flow/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第十二章：grpc 数据流转"><meta property="og:description" content="grpc 数据流转 阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 《10 - grpc 协议编解码器》 和 《11 - grpc 协议解包过程全剖析》"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2019-11-12T00:00:00+08:00"><meta property="article:modified_time" content="2019-11-12T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第十二章：grpc 数据流转"><meta name=twitter:description content="grpc 数据流转
阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 《10 - grpc 协议编解码器》 和 《11 - grpc 协议解包过程全剖析》"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"gRPC 源码阅读","item":"https://diu.life/lessons/grpc-read/"},{"@type":"ListItem","position":3,"name":"第十二章：grpc 数据流转","item":"https://diu.life/lessons/grpc-read/grpc-data-flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第十二章：grpc 数据流转","name":"第十二章：grpc 数据流转","description":"grpc 数据流转 阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 《10 - grpc 协议编解码器》 和 《11 - grpc 协议解包过程全剖析》\n","keywords":[],"articleBody":"grpc 数据流转 阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 《10 - grpc 协议编解码器》 和 《11 - grpc 协议解包过程全剖析》\n再谈协议 我们知道协议是一款 rpc 框架的基础。协议里面定义了一次客户端需要携带的信息，包括请求的后端服务名 ServiceName，方法名 Method、超时时间 Timeout、编码 Encoding、认证信息 Authority 等等。\n前面我们已经说到了，grpc 是基于 http2 协议的，我们来看看 grpc 协议里面的一些关键信息：\n可以看到，一次请求需要携带这么多信息，server 会根据 client 携带的这些信息来进行相应的处理。那么这些协议里面定义的内容要如何被传递下去呢？\n数据承载体 为了回答上面的问题，我们需要一个数据承载体结构，来保存协议里面的一些需要透传的一些重要信息，比如 Method 等。在 grpc 中，这个结构就是 Stream， 我们来看一下 Stream 的定义。\n// Stream represents an RPC in the transport layer. type Stream struct { id uint32 st ServerTransport // nil for client side Stream ctx context.Context // the associated context of the stream cancel context.CancelFunc // always nil for client side Stream done chan struct{} // closed at the end of stream to unblock writers. On the client side. ctxDone \u003c-chan struct{} // same as done chan but for server side. Cache of ctx.Done() (for performance) method string // the associated RPC method of the stream recvCompress string sendCompress string buf *recvBuffer trReader io.Reader fc *inFlow wq *writeQuota // Callback to state application's intentions to read data. This // is used to adjust flow control, if needed. requestRead func(int) headerChan chan struct{} // closed to indicate the end of header metadata. headerChanClosed uint32 // set when headerChan is closed. Used to avoid closing headerChan multiple times. // hdrMu protects header and trailer metadata on the server-side. hdrMu sync.Mutex // On client side, header keeps the received header metadata. // // On server side, header keeps the header set by SetHeader(). The complete // header will merged into this after t.WriteHeader() is called. header metadata.MD trailer metadata.MD // the key-value map of trailer metadata. noHeaders bool // set if the client never received headers (set only after the stream is done). // On the server-side, headerSent is atomically set to 1 when the headers are sent out. headerSent uint32 state streamState // On client-side it is the status error received from the server. // On server-side it is unused. status *status.Status bytesReceived uint32 // indicates whether any bytes have been received on this stream unprocessed uint32 // set if the server sends a refused stream or GOAWAY including this stream // contentSubtype is the content-subtype for requests. // this must be lowercase or the behavior is undefined. contentSubtype string } server 端 Stream 的构造 接下来我们来看看 server 端 Stream 的构造。前面的内容已经说过 server 的处理流程了。我们直接进入 serveStreams 这个方法。路径为：s.Serve(lis) ——\u003e s.handleRawConn(rawConn) ——\u003e s.serveStreams(st)\nfunc (s *Server) serveStreams(st transport.ServerTransport) { defer st.Close() var wg sync.WaitGroup st.HandleStreams(func(stream *transport.Stream) { wg.Add(1) go func() { defer wg.Done() s.handleStream(st, stream, s.traceInfo(st, stream)) }() }, func(ctx context.Context, method string) context.Context { if !EnableTracing { return ctx } tr := trace.New(\"grpc.Recv.\"+methodFamily(method), method) return trace.NewContext(ctx, tr) }) wg.Wait() } 最上层 HandleStreams 是对 http2 数据帧的处理。grpc 一共处理了 MetaHeadersFrame 、DataFrame、RSTStreamFrame、SettingsFrame、PingFrame、WindowUpdateFrame、GoAwayFrame 等 7 种帧。\n// HandleStreams receives incoming streams using the given handler. This is // typically run in a separate goroutine. // traceCtx attaches trace to ctx and returns the new context. func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) { defer close(t.readerDone) for { frame, err := t.framer.fr.ReadFrame() atomic.StoreUint32(\u0026t.activity, 1) if err != nil { if se, ok := err.(http2.StreamError); ok { warningf(\"transport: http2Server.HandleStreams encountered http2.StreamError: %v\", se) t.mu.Lock() s := t.activeStreams[se.StreamID] t.mu.Unlock() if s != nil { t.closeStream(s, true, se.Code, false) } else { t.controlBuf.put(\u0026cleanupStream{ streamID: se.StreamID, rst: true, rstCode: se.Code, onWrite: func() {}, }) } continue } if err == io.EOF || err == io.ErrUnexpectedEOF { t.Close() return } warningf(\"transport: http2Server.HandleStreams failed to read frame: %v\", err) t.Close() return } switch frame := frame.(type) { case *http2.MetaHeadersFrame: if t.operateHeaders(frame, handle, traceCtx) { t.Close() break } case *http2.DataFrame: t.handleData(frame) case *http2.RSTStreamFrame: t.handleRSTStream(frame) case *http2.SettingsFrame: t.handleSettings(frame) case *http2.PingFrame: t.handlePing(frame) case *http2.WindowUpdateFrame: t.handleWindowUpdate(frame) case *http2.GoAwayFrame: // TODO: Handle GoAway from the client appropriately. default: errorf(\"transport: http2Server.HandleStreams found unhandled frame type %v.\", frame) } } } 对于每一次请求而言，client 一定会先发 HeadersFrame 这个帧，grpc 这里是直接使用 http2 工具包进行实现，直接处理的 MetaHeadersFrame 帧，这个帧的定义为：\n// A MetaHeadersFrame is the representation of one HEADERS frame and // zero or more contiguous CONTINUATION frames and the decoding of // their HPACK-encoded contents. // // This type of frame does not appear on the wire and is only returned // by the Framer when Framer.ReadMetaHeaders is set. type MetaHeadersFrame struct { *HeadersFrame Fields []hpack.HeaderField Truncated bool } 所以是在 MetaHeadersFrame 这个帧里去处理包头数据。所以会去执行 operateHeaders 这个方法，在这个方法里面会去构造一个 stream ，这个 stream 里面包含了传输层请求上下文的数据。包括方法名等。\ns := \u0026Stream{ id: streamID, st: t, buf: buf, fc: \u0026inFlow{limit: uint32(t.initialWindowSize)}, recvCompress: state.data.encoding, method: state.data.method, contentSubtype: state.data.contentSubtype, } 构造完 stream 后，接下来 tranport 对数据的处理都会将 stream 层层透传下去。所以整个请求内所需要的数据都从 stream 中可以得到，这样就实现了 server 端的数据流转。\nclient 端数据流转 与 server 相对应，client 端也有一个 clientStream 结构，定义如下：\n// clientStream implements a client side Stream. type clientStream struct { callHdr *transport.CallHdr opts []CallOption callInfo *callInfo cc *ClientConn desc *StreamDesc codec baseCodec cp Compressor comp encoding.Compressor cancel context.CancelFunc // cancels all attempts sentLast bool // sent an end stream beginTime time.Time methodConfig *MethodConfig ctx context.Context // the application's context, wrapped by stats/tracing retryThrottler *retryThrottler // The throttler active when the RPC began. binlog *binarylog.MethodLogger // Binary logger, can be nil. // serverHeaderBinlogged is a boolean for whether server header has been // logged. Server header will be logged when the first time one of those // happens: stream.Header(), stream.Recv(). // // It's only read and used by Recv() and Header(), so it doesn't need to be // synchronized. serverHeaderBinlogged bool mu sync.Mutex firstAttempt bool // if true, transparent retry is valid numRetries int // exclusive of transparent retry attempt(s) numRetriesSincePushback int // retries since pushback; to reset backoff finished bool // TODO: replace with atomic cmpxchg or sync.Once? attempt *csAttempt // the active client stream attempt // TODO(hedging): hedging will have multiple attempts simultaneously. committed bool // active attempt committed for retry? buffer []func(a *csAttempt) error // operations to replay on retry bufferSize int // current size of buffer } client 的构造就更直接了，在 invoke 发起下游调用时， 直接在 sendMsg 之前就会提前构造 clientStream， 如下：\nfunc invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts ...CallOption) error { cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...) if err != nil { return err } if err := cs.SendMsg(req); err != nil { return err } return cs.RecvMsg(reply) } stream 这个结构承载了数据流转之外，同时 grpc 流式传输的实现也是基于 stream 去实现的。\n","wordCount":"1725","inLanguage":"zh","datePublished":"2019-11-12T00:00:00+08:00","dateModified":"2019-11-12T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/grpc-read/grpc-data-flow/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li><li><a href=https://diu.life/privacy-policy/ title=隐私政策><span>隐私政策</span></a></li><li><a href=https://diu.life/terms-of-service/ title=服务条款><span>服务条款</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Grpc-Read 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-concepts-http2/ class=chapter-link><span class=chapter-title>第一章：grpc concepts & http2</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world/ class=chapter-link><span class=chapter-title>第二章：grpc hello world</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/ class=chapter-link><span class=chapter-title>第三章：grpc hello world server 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/ class=chapter-link><span class=chapter-title>第四章：grpc hello world client 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-service-discovery/ class=chapter-link><span class=chapter-title>第五章：grpc 服务发现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-load-balancing/ class=chapter-link><span class=chapter-title>第六章：grpc 负载均衡</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-tls/ class=chapter-link><span class=chapter-title>第七章：grpc 认证鉴权——tls认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-oauth2/ class=chapter-link><span class=chapter-title>第八章：grpc 认证鉴权——oauth2认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/ class=chapter-link><span class=chapter-title>第九章：grpc 拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/ class=chapter-link><span class=chapter-title>第十章：grpc 协议编解码器</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/ class=chapter-link><span class=chapter-title>第十一章：grpc 协议解包过程全剖析</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/grpc-read/grpc-data-flow/ class=chapter-link><span class=chapter-title>第十二章：grpc 数据流转</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第十二章：grpc 数据流转</h1><div class=post-meta><time datetime=2019-11-12T00:00:00+08:00>2019-11-12</time></div></header><div class=post-content><h1 id=grpc-数据流转>grpc 数据流转</h1><p>阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 <a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/>《10 - grpc 协议编解码器》</a> 和 <a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/>《11 - grpc 协议解包过程全剖析》</a></p><h2 id=再谈协议>再谈协议</h2><p>我们知道协议是一款 rpc 框架的基础。协议里面定义了一次客户端需要携带的信息，包括请求的后端服务名 ServiceName，方法名 Method、超时时间 Timeout、编码 Encoding、认证信息 Authority 等等。</p><p>前面我们已经说到了，grpc 是基于 http2 协议的，我们来看看 grpc 协议里面的一些关键信息：</p><p><img alt="grpc 协议" loading=lazy src=/images/grpc-read/12-1.jpg></p><p>可以看到，一次请求需要携带这么多信息，server 会根据 client 携带的这些信息来进行相应的处理。那么这些协议里面定义的内容要如何被传递下去呢？</p><h2 id=数据承载体>数据承载体</h2><p>为了回答上面的问题，我们需要一个数据承载体结构，来保存协议里面的一些需要透传的一些重要信息，比如 Method 等。在 grpc 中，这个结构就是 Stream， 我们来看一下 Stream 的定义。</p><pre><code>// Stream represents an RPC in the transport layer.
type Stream struct {
	id           uint32
	st           ServerTransport    // nil for client side Stream
	ctx          context.Context    // the associated context of the stream
	cancel       context.CancelFunc // always nil for client side Stream
	done         chan struct{}      // closed at the end of stream to unblock writers. On the client side.
	ctxDone      &lt;-chan struct{}    // same as done chan but for server side. Cache of ctx.Done() (for performance)
	method       string             // the associated RPC method of the stream
	recvCompress string
	sendCompress string
	buf          *recvBuffer
	trReader     io.Reader
	fc           *inFlow
	wq           *writeQuota

	// Callback to state application's intentions to read data. This
	// is used to adjust flow control, if needed.
	requestRead func(int)

	headerChan       chan struct{} // closed to indicate the end of header metadata.
	headerChanClosed uint32        // set when headerChan is closed. Used to avoid closing headerChan multiple times.

	// hdrMu protects header and trailer metadata on the server-side.
	hdrMu sync.Mutex
	// On client side, header keeps the received header metadata.
	//
	// On server side, header keeps the header set by SetHeader(). The complete
	// header will merged into this after t.WriteHeader() is called.
	header  metadata.MD
	trailer metadata.MD // the key-value map of trailer metadata.

	noHeaders bool // set if the client never received headers (set only after the stream is done).

	// On the server-side, headerSent is atomically set to 1 when the headers are sent out.
	headerSent uint32

	state streamState

	// On client-side it is the status error received from the server.
	// On server-side it is unused.
	status *status.Status

	bytesReceived uint32 // indicates whether any bytes have been received on this stream
	unprocessed   uint32 // set if the server sends a refused stream or GOAWAY including this stream

	// contentSubtype is the content-subtype for requests.
	// this must be lowercase or the behavior is undefined.
	contentSubtype string
}
</code></pre><h3 id=server-端-stream-的构造>server 端 Stream 的构造</h3><p>接下来我们来看看 server 端 Stream 的构造。前面的内容已经说过 server 的处理流程了。我们直接进入 serveStreams 这个方法。路径为：s.Serve(lis) ——> s.handleRawConn(rawConn) ——> s.serveStreams(st)</p><pre><code>func (s *Server) serveStreams(st transport.ServerTransport) {
	defer st.Close()
	var wg sync.WaitGroup
	st.HandleStreams(func(stream *transport.Stream) {
		wg.Add(1)
		go func() {
			defer wg.Done()
			s.handleStream(st, stream, s.traceInfo(st, stream))
		}()
	}, func(ctx context.Context, method string) context.Context {
		if !EnableTracing {
			return ctx
		}
		tr := trace.New(&quot;grpc.Recv.&quot;+methodFamily(method), method)
		return trace.NewContext(ctx, tr)
	})
	wg.Wait()
}
</code></pre><p>最上层 HandleStreams 是对 http2 数据帧的处理。grpc 一共处理了 MetaHeadersFrame 、DataFrame、RSTStreamFrame、SettingsFrame、PingFrame、WindowUpdateFrame、GoAwayFrame 等 7 种帧。</p><pre><code>// HandleStreams receives incoming streams using the given handler. This is
// typically run in a separate goroutine.
// traceCtx attaches trace to ctx and returns the new context.
func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) {
	defer close(t.readerDone)
	for {
		frame, err := t.framer.fr.ReadFrame()
		atomic.StoreUint32(&amp;t.activity, 1)
		if err != nil {
			if se, ok := err.(http2.StreamError); ok {
				warningf(&quot;transport: http2Server.HandleStreams encountered http2.StreamError: %v&quot;, se)
				t.mu.Lock()
				s := t.activeStreams[se.StreamID]
				t.mu.Unlock()
				if s != nil {
					t.closeStream(s, true, se.Code, false)
				} else {
					t.controlBuf.put(&amp;cleanupStream{
						streamID: se.StreamID,
						rst:      true,
						rstCode:  se.Code,
						onWrite:  func() {},
					})
				}
				continue
			}
			if err == io.EOF || err == io.ErrUnexpectedEOF {
				t.Close()
				return
			}
			warningf(&quot;transport: http2Server.HandleStreams failed to read frame: %v&quot;, err)
			t.Close()
			return
		}
		switch frame := frame.(type) {
		case *http2.MetaHeadersFrame:
			if t.operateHeaders(frame, handle, traceCtx) {
				t.Close()
				break
			}
		case *http2.DataFrame:
			t.handleData(frame)
		case *http2.RSTStreamFrame:
			t.handleRSTStream(frame)
		case *http2.SettingsFrame:
			t.handleSettings(frame)
		case *http2.PingFrame:
			t.handlePing(frame)
		case *http2.WindowUpdateFrame:
			t.handleWindowUpdate(frame)
		case *http2.GoAwayFrame:
			// TODO: Handle GoAway from the client appropriately.
		default:
			errorf(&quot;transport: http2Server.HandleStreams found unhandled frame type %v.&quot;, frame)
		}
	}
}
</code></pre><p>对于每一次请求而言，client 一定会先发 HeadersFrame 这个帧，grpc 这里是直接使用 http2 工具包进行实现，直接处理的 MetaHeadersFrame 帧，这个帧的定义为：</p><pre><code>// A MetaHeadersFrame is the representation of one HEADERS frame and
// zero or more contiguous CONTINUATION frames and the decoding of
// their HPACK-encoded contents.
//
// This type of frame does not appear on the wire and is only returned
// by the Framer when Framer.ReadMetaHeaders is set.
type MetaHeadersFrame struct {
        *HeadersFrame
        Fields []hpack.HeaderField
        Truncated bool
}
</code></pre><p>所以是在 MetaHeadersFrame 这个帧里去处理包头数据。所以会去执行 operateHeaders 这个方法，在这个方法里面会去构造一个 stream ，这个 stream 里面包含了传输层请求上下文的数据。包括方法名等。</p><pre><code>s := &amp;Stream{
		id:             streamID,
		st:             t,
		buf:            buf,
		fc:             &amp;inFlow{limit: uint32(t.initialWindowSize)},
		recvCompress:   state.data.encoding,
		method:         state.data.method,
		contentSubtype: state.data.contentSubtype,
	}
</code></pre><p>构造完 stream 后，接下来 tranport 对数据的处理都会将 stream 层层透传下去。所以整个请求内所需要的数据都从 stream 中可以得到，这样就实现了 server 端的数据流转。</p><h3 id=client-端数据流转>client 端数据流转</h3><p>与 server 相对应，client 端也有一个 clientStream 结构，定义如下：</p><pre><code>// clientStream implements a client side Stream.
type clientStream struct {
	callHdr  *transport.CallHdr
	opts     []CallOption
	callInfo *callInfo
	cc       *ClientConn
	desc     *StreamDesc

	codec baseCodec
	cp    Compressor
	comp  encoding.Compressor

	cancel context.CancelFunc // cancels all attempts

	sentLast  bool // sent an end stream
	beginTime time.Time

	methodConfig *MethodConfig

	ctx context.Context // the application's context, wrapped by stats/tracing

	retryThrottler *retryThrottler // The throttler active when the RPC began.

	binlog *binarylog.MethodLogger // Binary logger, can be nil.
	// serverHeaderBinlogged is a boolean for whether server header has been
	// logged. Server header will be logged when the first time one of those
	// happens: stream.Header(), stream.Recv().
	//
	// It's only read and used by Recv() and Header(), so it doesn't need to be
	// synchronized.
	serverHeaderBinlogged bool

	mu                      sync.Mutex
	firstAttempt            bool       // if true, transparent retry is valid
	numRetries              int        // exclusive of transparent retry attempt(s)
	numRetriesSincePushback int        // retries since pushback; to reset backoff
	finished                bool       // TODO: replace with atomic cmpxchg or sync.Once?
	attempt                 *csAttempt // the active client stream attempt
	// TODO(hedging): hedging will have multiple attempts simultaneously.
	committed  bool                       // active attempt committed for retry?
	buffer     []func(a *csAttempt) error // operations to replay on retry
	bufferSize int                        // current size of buffer
}
</code></pre><p>client 的构造就更直接了，在 invoke 发起下游调用时， 直接在 sendMsg 之前就会提前构造 clientStream， 如下：</p><pre><code>func invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts ...CallOption) error {
	cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)
	if err != nil {
		return err
	}
	if err := cs.SendMsg(req); err != nil {
		return err
	}
	return cs.RecvMsg(reply)
}
</code></pre><p>stream 这个结构承载了数据流转之外，同时 grpc 流式传输的实现也是基于 stream 去实现的。</p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第十一章：grpc 协议解包过程全剖析</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2021 丢哥 all rights reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>