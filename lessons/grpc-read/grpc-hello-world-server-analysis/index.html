<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第三章：grpc hello world server 解析 | 丢哥</title><meta name=keywords content><meta name=description content="grpc hello world server 解析
我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&mldr;&mldr;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2499390968830075" crossorigin=anonymous></script><style>.footer-content{display:flex;justify-content:center;align-items:center;flex-wrap:wrap;gap:20px;text-align:center}.footer-links{font-size:.9em;opacity:.8;white-space:nowrap}.footer-links a{color:inherit;text-decoration:none;margin:0 5px}.footer-links a:hover{text-decoration:underline}.footer-links a:first-child{margin-left:0}.footer-links a:last-child{margin-right:0}@media(max-width:600px){.footer-content{flex-direction:column;align-items:center;gap:10px}.footer-copyright{text-align:center}}</style><meta property="og:url" content="https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第三章：grpc hello world server 解析"><meta property="og:description" content="grpc hello world server 解析 我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？…….这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2019-11-03T00:00:00+08:00"><meta property="article:modified_time" content="2019-11-03T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第三章：grpc hello world server 解析"><meta name=twitter:description content="grpc hello world server 解析
我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&mldr;&mldr;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"gRPC 源码阅读","item":"https://diu.life/lessons/grpc-read/"},{"@type":"ListItem","position":3,"name":"第三章：grpc hello world server 解析","item":"https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第三章：grpc hello world server 解析","name":"第三章：grpc hello world server 解析","description":"grpc hello world server 解析 我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？\u0026hellip;\u0026hellip;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。\n","keywords":[],"articleBody":"grpc hello world server 解析 我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？…….这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。\n这节内容我们先来研究一下 server 端连接建立过程。\n先放上 server 端的 main 函数。\nfunc main() { lis, err := net.Listen(\"tcp\", port) if err != nil { log.Fatalf(\"failed to listen: %v\", err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, \u0026server{}) if err := s.Serve(lis); err != nil { log.Fatalf(\"failed to serve: %v\", err) } } 我们发现其实 server 端连接的建立主要包括三步：\n（1）创建 server\n（2）server 的注册\n（3）调用 Serve 监听端口并处理请求\nok，弄清楚主流程之后下面我们进入每个步骤里面去看一下代码实现。\n1、创建 server server 的创建比较简单，其实就下面一个方法：\nfunc NewServer(opt ...ServerOption) *Server { opts := defaultServerOptions for _, o := range opt { o.apply(\u0026opts) } s := \u0026Server{ lis: make(map[net.Listener]bool), opts: opts, conns: make(map[transport.ServerTransport]bool), m: make(map[string]*service), quit: grpcsync.NewEvent(), done: grpcsync.NewEvent(), czData: new(channelzData), } s.cv = sync.NewCond(\u0026s.mu) if EnableTracing { _, file, line, _ := runtime.Caller(1) s.events = trace.NewEventLog(\"grpc.Server\", fmt.Sprintf(\"%s:%d\", file, line)) } if channelz.IsOn() { s.channelzID = channelz.RegisterServer(\u0026channelzServer{s}, \"\") } return s } 这个方法的核心无非是创建了一个 server 结构体，然后为结构体的属性赋值。我们顺便来瞅瞅 server 的结构：\n// Server is a gRPC server to serve RPC requests. type Server struct { // serverOptions 就是描述协议的各种参数选项，包括发送和接收的消息大小、buffer大小等等各种，跟 http Headers 类似，我们这里就暂时先不管 opts serverOptions // 一个互斥锁 mu sync.Mutex // guards following // listener map lis map[net.Listener]bool // connections map conns map[transport.ServerTransport]bool // server 是否在处理请求的一个状态位 serve bool drain bool cv *sync.Cond // signaled when connections close for GracefulStop // service map m map[string]*service // service name -\u003e service info events trace.EventLog quit *grpcsync.Event done *grpcsync.Event channelzRemoveOnce sync.Once serveWG sync.WaitGroup // counts active Serve goroutines for GracefulStop channelzID int64 // channelz unique identification number czData *channelzData } 虽然 server 结构体里面各种乱起八糟的字段，但是我们可以先不管哈哈哈，比较重要的无非就是三个 map 表分别用来存放多个 listener 、connection 和 service。其他字段都是为了实现协议描述或者并发控制的功能。我们重点关注下\nm map[string]*service 这个结构，service 中主要包含了 MethodDesc 和 StreamDesc 这两个 map\ntype service struct { server interface{} // the server for service methods md map[string]*MethodDesc sd map[string]*StreamDesc mdata interface{} } 2、server 注册 server 的注册调用了 RegisterGreeterServer 方法，这个方法是 pb.go 文件里面的，如下：\nfunc RegisterGreeterServer(s *grpc.Server, srv GreeterServer) { s.RegisterService(\u0026_Greeter_serviceDesc, srv) } 这个方法调用了 server 的 RegisterService 方法，然后传入了一个 ServiceDesc 的数据结构，如下 ：\nvar _Greeter_serviceDesc = grpc.ServiceDesc{ ServiceName: \"helloworld.Greeter\", HandlerType: (*GreeterServer)(nil), Methods: []grpc.MethodDesc{ { MethodName: \"SayHello\", Handler: _Greeter_SayHello_Handler, }, { MethodName: \"SayHelloAgain\", Handler: _Greeter_SayHelloAgain_Handler, }, }, Streams: []grpc.StreamDesc{}, Metadata: \"helloworld.proto\", } 我们来看看 RegisterService 这个方法，可以看到主要是调用了 register 方法，register 方法则按照方法名为 key，将方法注入到 server 的 service map 中。看到这里我们其实可以预测一下，server 不同 rpc 请求的处理，也是根据 service 中不同的 serviceName 去 service map 中取出不同的 handler 进行处理\nfunc (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) { ht := reflect.TypeOf(sd.HandlerType).Elem() st := reflect.TypeOf(ss) if !st.Implements(ht) { grpclog.Fatalf(\"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v\", st, ht) } s.register(sd, ss) } func (s *Server) register(sd *ServiceDesc, ss interface{}) { s.mu.Lock() defer s.mu.Unlock() s.printf(\"RegisterService(%q)\", sd.ServiceName) if s.serve { grpclog.Fatalf(\"grpc: Server.RegisterService after Server.Serve for %q\", sd.ServiceName) } if _, ok := s.m[sd.ServiceName]; ok { grpclog.Fatalf(\"grpc: Server.RegisterService found duplicate service registration for %q\", sd.ServiceName) } srv := \u0026service{ server: ss, md: make(map[string]*MethodDesc), sd: make(map[string]*StreamDesc), mdata: sd.Metadata, } for i := range sd.Methods { d := \u0026sd.Methods[i] srv.md[d.MethodName] = d } for i := range sd.Streams { d := \u0026sd.Streams[i] srv.sd[d.StreamName] = d } s.m[sd.ServiceName] = srv } 3、Serve 过程 回想所有 C/S 模式下，client 和 server 的通信基本是类似的。大致过程无非是 server 通过死循环的方式在某一个端口实现监听，然后 client 对这个端口发起连接请求，握手成功后建立连接，然后 server 处理 client 发送过来的请求数据，根据请求类型和请求参数，调用不同的 handler 进行处理，回写响应数据。\n所以，对 server 端来说，主要是了解其如何实现监听，如何为请求分配不同的 handler 和 回写响应数据。\n上面我们得知 server 调用了 Serve 方法来进行处理，所以立马就想跟进去看看。 跳过前面一堆条件检查和控制代码，直接锁定了一个 for 循环，如下：（中间的一些代码已省略）\nfor { rawConn, err := lis.Accept() ...... s.serveWG.Add(1) go func() { s.handleRawConn(rawConn) s.serveWG.Done() }() } ok，我们已经看到了监听过程，server 的监听果然是通过一个死循环 调用了 lis.Accept() 进行端口监听。\n继续往下看，我们发现新起协程调用了 handleRawConn 这个方法，为了节约篇幅，我们直接看重点代码，如下：\nfunc (s *Server) handleRawConn(rawConn net.Conn) { ... conn, authInfo, err := s.useTransportAuthenticator(rawConn) ... // Finish handshaking (HTTP2) st := s.newHTTP2Transport(conn, authInfo) if st == nil { return } ... go func() { s.serveStreams(st) s.removeConn(st) }() } 可以看到 handleRawConn 里面实现了 http 的 handshake，还记得之前我们说过，grpc 是基于 http2 实现的吗？这里是不是实锤了……. 发现又通过一个新的协程调用了 serveStreams 这个方法，这个方法干了啥呢？\nfunc (s *Server) serveStreams(st transport.ServerTransport) { defer st.Close() var wg sync.WaitGroup st.HandleStreams(func(stream *transport.Stream) { wg.Add(1) go func() { defer wg.Done() s.handleStream(st, stream, s.traceInfo(st, stream)) }() }, func(ctx context.Context, method string) context.Context { if !EnableTracing { return ctx } tr := trace.New(\"grpc.Recv.\"+methodFamily(method), method) return trace.NewContext(ctx, tr) }) wg.Wait() } 其实它主要调用了 handleStream ，继续跟进 handleStream 方法，我们发现了重要线索，如下（省略了部分无关代码）\nfunc (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) { sm := stream.Method() ... service := sm[:pos] method := sm[pos+1:] srv, knownService := s.m[service] if knownService { if md, ok := srv.md[method]; ok { s.processUnaryRPC(t, stream, srv, md, trInfo) return } if sd, ok := srv.sd[method]; ok { s.processStreamingRPC(t, stream, srv, sd, trInfo) return } } ... } 重要线索就是这一行\nsrv, knownService := s.m[service] 还记得我们之前的预测吗？根据 serviceName 去 server 中的 service map，也就是 m 这个字段，里面去取出 handler 进行处理。我们 hello world 这个 demo 的请求不涉及到 stream ，所以直接取出 handler ，然后传给 processUnaryRPC 这个方法进行处理。\nif md, ok := srv.md[method]; ok { s.processUnaryRPC(t, stream, srv, md, trInfo) return } 再来看看 processUnaryRpc 这个方法\nfunc (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) { ... sh := s.opts.statsHandler if sh != nil { beginTime := time.Now() begin := \u0026stats.Begin{ BeginTime: beginTime, } sh.HandleRPC(stream.Context(), begin) defer func() { end := \u0026stats.End{ BeginTime: beginTime, EndTime: time.Now(), } if err != nil \u0026\u0026 err != io.EOF { end.Error = toRPCErr(err) } sh.HandleRPC(stream.Context(), end) }() } ... if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil { if err == io.EOF { // The entire stream is done (for unary RPC only). return err } if s, ok := status.FromError(err); ok { if e := t.WriteStatus(stream, s); e != nil { grpclog.Warningf(\"grpc: Server.processUnaryRPC failed to write status: %v\", e) } } else { switch st := err.(type) { case transport.ConnectionError: // Nothing to do here. default: panic(fmt.Sprintf(\"grpc: Unexpected error (%T) from sendResponse: %v\", st, st)) } } if binlog != nil { h, _ := stream.Header() binlog.Log(\u0026binarylog.ServerHeader{ Header: h, }) binlog.Log(\u0026binarylog.ServerTrailer{ Trailer: stream.Trailer(), Err: appErr, }) } return err } ... } 我们终于看到了 handler 对 rpc 的处理：\nsh := s.opts.statsHandler sh.HandleRPC(stream.Context(), begin) sh.HandleRPC(stream.Context(), end) 同时也看到了 response 的回写\ns.sendResponse(t, stream, reply, cp, opts, comp) 至此，server 端我们的目标实现，追踪到了整个请求和监听、handler 处理 和 response 回写的过程。\n","wordCount":"2079","inLanguage":"zh","datePublished":"2019-11-03T00:00:00+08:00","dateModified":"2019-11-03T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Grpc-Read 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-concepts-http2/ class=chapter-link><span class=chapter-title>第一章：grpc concepts & http2</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world/ class=chapter-link><span class=chapter-title>第二章：grpc hello world</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/ class=chapter-link><span class=chapter-title>第三章：grpc hello world server 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/ class=chapter-link><span class=chapter-title>第四章：grpc hello world client 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-service-discovery/ class=chapter-link><span class=chapter-title>第五章：grpc 服务发现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-load-balancing/ class=chapter-link><span class=chapter-title>第六章：grpc 负载均衡</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-tls/ class=chapter-link><span class=chapter-title>第七章：grpc 认证鉴权——tls认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-oauth2/ class=chapter-link><span class=chapter-title>第八章：grpc 认证鉴权——oauth2认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/ class=chapter-link><span class=chapter-title>第九章：grpc 拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/ class=chapter-link><span class=chapter-title>第十章：grpc 协议编解码器</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/ class=chapter-link><span class=chapter-title>第十一章：grpc 协议解包过程全剖析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-data-flow/ class=chapter-link><span class=chapter-title>第十二章：grpc 数据流转</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第三章：grpc hello world server 解析</h1><div class=post-meta><time datetime=2019-11-03T00:00:00+08:00>2019-11-03</time></div></header><div class=post-content><h3 id=grpc-hello-world-server-解析>grpc hello world server 解析</h3><p>我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&mldr;&mldr;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。</p><p>这节内容我们先来研究一下 server 端连接建立过程。</p><p>先放上 server 端的 main 函数。</p><pre><code>func main() {
	lis, err := net.Listen(&quot;tcp&quot;, port)
	if err != nil {
		log.Fatalf(&quot;failed to listen: %v&quot;, err)
	}
	s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &amp;server{})
	if err := s.Serve(lis); err != nil {
		log.Fatalf(&quot;failed to serve: %v&quot;, err)
	}
}
</code></pre><p>我们发现其实 server 端连接的建立主要包括三步：</p><p>（1）创建 server</p><p>（2）server 的注册</p><p>（3）调用 Serve 监听端口并处理请求</p><p>ok，弄清楚主流程之后下面我们进入每个步骤里面去看一下代码实现。</p><h4 id=1创建--server>1、创建 server</h4><p>server 的创建比较简单，其实就下面一个方法：</p><pre><code>func NewServer(opt ...ServerOption) *Server {
	opts := defaultServerOptions
	for _, o := range opt {
		o.apply(&amp;opts)
	}
	s := &amp;Server{
		lis:    make(map[net.Listener]bool),
		opts:   opts,
		conns:  make(map[transport.ServerTransport]bool),
		m:      make(map[string]*service),
		quit:   grpcsync.NewEvent(),
		done:   grpcsync.NewEvent(),
		czData: new(channelzData),
	}
	s.cv = sync.NewCond(&amp;s.mu)
	if EnableTracing {
		_, file, line, _ := runtime.Caller(1)
		s.events = trace.NewEventLog(&quot;grpc.Server&quot;, fmt.Sprintf(&quot;%s:%d&quot;, file, line))
	}

	if channelz.IsOn() {
		s.channelzID = channelz.RegisterServer(&amp;channelzServer{s}, &quot;&quot;)
	}
	return s
}
</code></pre><p>这个方法的核心无非是创建了一个 server 结构体，然后为结构体的属性赋值。我们顺便来瞅瞅 server 的结构：</p><pre><code>// Server is a gRPC server to serve RPC requests.
type Server struct {
	// serverOptions 就是描述协议的各种参数选项，包括发送和接收的消息大小、buffer大小等等各种，跟 http Headers 类似，我们这里就暂时先不管
	opts serverOptions

	// 一个互斥锁
	mu     sync.Mutex // guards following
	// listener map
	lis    map[net.Listener]bool
	// connections map
	conns  map[transport.ServerTransport]bool
	// server 是否在处理请求的一个状态位
	serve  bool
	drain  bool
	cv     *sync.Cond          // signaled when connections close for GracefulStop
	// service map
	m      map[string]*service // service name -&gt; service info
	events trace.EventLog

	quit               *grpcsync.Event
	done               *grpcsync.Event
	channelzRemoveOnce sync.Once
	serveWG            sync.WaitGroup // counts active Serve goroutines for GracefulStop

	channelzID int64 // channelz unique identification number
	czData     *channelzData
}
</code></pre><p>虽然 server 结构体里面各种乱起八糟的字段，但是我们可以先不管哈哈哈，比较重要的无非就是三个 map 表分别用来存放多个 listener 、connection 和 service。其他字段都是为了实现协议描述或者并发控制的功能。我们重点关注下</p><pre><code>m      map[string]*service 
</code></pre><p>这个结构，service 中主要包含了 MethodDesc 和 StreamDesc 这两个 map</p><pre><code>type service struct {
	server interface{} // the server for service methods
	md     map[string]*MethodDesc
	sd     map[string]*StreamDesc
	mdata  interface{}
}
</code></pre><h4 id=2server-注册>2、server 注册</h4><p>server 的注册调用了 RegisterGreeterServer 方法，这个方法是 pb.go 文件里面的，如下：</p><pre><code>func RegisterGreeterServer(s *grpc.Server, srv GreeterServer) {
	s.RegisterService(&amp;_Greeter_serviceDesc, srv)
}
</code></pre><p>这个方法调用了 server 的 RegisterService 方法，然后传入了一个 ServiceDesc 的数据结构，如下 ：</p><pre><code>var _Greeter_serviceDesc = grpc.ServiceDesc{
	ServiceName: &quot;helloworld.Greeter&quot;,
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: &quot;SayHello&quot;,
			Handler:    _Greeter_SayHello_Handler,
		},
		{
			MethodName: &quot;SayHelloAgain&quot;,
			Handler:    _Greeter_SayHelloAgain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: &quot;helloworld.proto&quot;,
}
</code></pre><p>我们来看看 RegisterService 这个方法，可以看到主要是调用了 register 方法，register 方法则按照方法名为 key，将方法注入到 server 的 service map 中。看到这里我们其实可以预测一下，server 不同 rpc 请求的处理，也是根据 service 中不同的 serviceName 去 service map 中取出不同的 handler 进行处理</p><pre><code>func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
	ht := reflect.TypeOf(sd.HandlerType).Elem()
	st := reflect.TypeOf(ss)
	if !st.Implements(ht) {
		grpclog.Fatalf(&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;, st, ht)
	}
	s.register(sd, ss)
}

func (s *Server) register(sd *ServiceDesc, ss interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.printf(&quot;RegisterService(%q)&quot;, sd.ServiceName)
	if s.serve {
		grpclog.Fatalf(&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;, sd.ServiceName)
	}
	if _, ok := s.m[sd.ServiceName]; ok {
		grpclog.Fatalf(&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;, sd.ServiceName)
	}
	srv := &amp;service{
		server: ss,
		md:     make(map[string]*MethodDesc),
		sd:     make(map[string]*StreamDesc),
		mdata:  sd.Metadata,
	}
	for i := range sd.Methods {
		d := &amp;sd.Methods[i]
		srv.md[d.MethodName] = d
	}
	for i := range sd.Streams {
		d := &amp;sd.Streams[i]
		srv.sd[d.StreamName] = d
	}
	s.m[sd.ServiceName] = srv
}
</code></pre><h4 id=3serve-过程>3、Serve 过程</h4><p>回想所有 C/S 模式下，client 和 server 的通信基本是类似的。大致过程无非是 server 通过死循环的方式在某一个端口实现监听，然后 client 对这个端口发起连接请求，握手成功后建立连接，然后 server 处理 client 发送过来的请求数据，根据请求类型和请求参数，调用不同的 handler 进行处理，回写响应数据。</p><p>所以，对 server 端来说，主要是了解其如何实现监听，如何为请求分配不同的 handler 和 回写响应数据。</p><p>上面我们得知 server 调用了 Serve 方法来进行处理，所以立马就想跟进去看看。
跳过前面一堆条件检查和控制代码，直接锁定了一个 for 循环，如下：（中间的一些代码已省略）</p><pre><code>for {
		rawConn, err := lis.Accept()
		
		......

		s.serveWG.Add(1)
		go func() {
			s.handleRawConn(rawConn)
			s.serveWG.Done()
		}()
	}
</code></pre><p>ok，我们已经看到了监听过程，server 的监听果然是通过一个死循环 调用了 lis.Accept() 进行端口监听。</p><p>继续往下看，我们发现新起协程调用了 handleRawConn 这个方法，为了节约篇幅，我们直接看重点代码，如下：</p><pre><code>func (s *Server) handleRawConn(rawConn net.Conn) {
	
	...

	conn, authInfo, err := s.useTransportAuthenticator(rawConn)
	
	...

	// Finish handshaking (HTTP2)
	st := s.newHTTP2Transport(conn, authInfo)
	if st == nil {
		return
	}
	...
	
	go func() {
		s.serveStreams(st)
		s.removeConn(st)
	}()
}
</code></pre><p>可以看到 handleRawConn 里面实现了 http 的 handshake，还记得之前我们说过，grpc 是基于 http2 实现的吗？这里是不是实锤了&mldr;&mldr;. 发现又通过一个新的协程调用了 serveStreams 这个方法，这个方法干了啥呢？</p><pre><code>func (s *Server) serveStreams(st transport.ServerTransport) {
	defer st.Close()
	var wg sync.WaitGroup
	st.HandleStreams(func(stream *transport.Stream) {
		wg.Add(1)
		go func() {
			defer wg.Done()
			s.handleStream(st, stream, s.traceInfo(st, stream))
		}()
	}, func(ctx context.Context, method string) context.Context {
		if !EnableTracing {
			return ctx
		}
		tr := trace.New(&quot;grpc.Recv.&quot;+methodFamily(method), method)
		return trace.NewContext(ctx, tr)
	})
	wg.Wait()
}
</code></pre><p>其实它主要调用了 handleStream ，继续跟进 handleStream 方法，我们发现了重要线索，如下（省略了部分无关代码）</p><pre><code>func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
	sm := stream.Method()
	
	...

	service := sm[:pos]
	method := sm[pos+1:]

	srv, knownService := s.m[service]
	if knownService {
		if md, ok := srv.md[method]; ok {
			s.processUnaryRPC(t, stream, srv, md, trInfo)
			return
		}
		if sd, ok := srv.sd[method]; ok {
			s.processStreamingRPC(t, stream, srv, sd, trInfo)
			return
		}
	}
	
	...
}
</code></pre><p>重要线索就是这一行</p><pre><code>	srv, knownService := s.m[service]
</code></pre><p>还记得我们之前的预测吗？根据 serviceName 去 server 中的 service map，也就是 m 这个字段，里面去取出 handler 进行处理。我们 hello world 这个 demo 的请求不涉及到 stream ，所以直接取出 handler ，然后传给 processUnaryRPC 这个方法进行处理。</p><pre><code>if md, ok := srv.md[method]; ok {
	s.processUnaryRPC(t, stream, srv, md, trInfo)
	return
}
</code></pre><p>再来看看 processUnaryRpc 这个方法</p><pre><code>func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {
		
	...

	sh := s.opts.statsHandler
	if sh != nil {
		beginTime := time.Now()
		begin := &amp;stats.Begin{
			BeginTime: beginTime,
		}
		sh.HandleRPC(stream.Context(), begin)
		defer func() {
			end := &amp;stats.End{
				BeginTime: beginTime,
				EndTime:   time.Now(),
			}
			if err != nil &amp;&amp; err != io.EOF {
				end.Error = toRPCErr(err)
			}
			sh.HandleRPC(stream.Context(), end)
		}()
	}
	
	...

	if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil {
		if err == io.EOF {
			// The entire stream is done (for unary RPC only).
			return err
		}
		if s, ok := status.FromError(err); ok {
			if e := t.WriteStatus(stream, s); e != nil {
				grpclog.Warningf(&quot;grpc: Server.processUnaryRPC failed to write status: %v&quot;, e)
			}
		} else {
			switch st := err.(type) {
			case transport.ConnectionError:
				// Nothing to do here.
			default:
				panic(fmt.Sprintf(&quot;grpc: Unexpected error (%T) from sendResponse: %v&quot;, st, st))
			}
		}
		if binlog != nil {
			h, _ := stream.Header()
			binlog.Log(&amp;binarylog.ServerHeader{
				Header: h,
			})
			binlog.Log(&amp;binarylog.ServerTrailer{
				Trailer: stream.Trailer(),
				Err:     appErr,
			})
		}
		return err
	}
	
	...
}
</code></pre><p>我们终于看到了 handler 对 rpc 的处理：</p><pre><code>	sh := s.opts.statsHandler
	sh.HandleRPC(stream.Context(), begin)
	sh.HandleRPC(stream.Context(), end)
</code></pre><p>同时也看到了 response 的回写</p><pre><code>s.sendResponse(t, stream, reply, cp, opts, comp)
</code></pre><p>至此，server 端我们的目标实现，追踪到了整个请求和监听、handler 处理 和 response 回写的过程。</p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/grpc-read/grpc-hello-world/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第二章：grpc hello world</span>
</a><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第四章：grpc hello world client 解析</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><div class=footer-content><div class=footer-copyright><span>&copy; 2024 丢哥 all rights reserved.</span></div><div class=footer-links><a href=/privacy-policy/ title=隐私政策>隐私政策</a> |
<a href=/terms-of-service/ title=服务条款>服务条款</a></div></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>