<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第十一章：grpc 协议解包过程全剖析 | 丢哥</title><meta name=keywords content><meta name=description content="http2 协议帧格式
我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。"><meta name=author content="丢哥"><link rel=canonical href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://diu.life/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://diu.life/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://diu.life/favicon-32x32.png><link rel=apple-touch-icon href=https://diu.life/apple-touch-icon.png><link rel=mask-icon href=https://diu.life/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2499390968830075" crossorigin=anonymous></script><meta property="og:url" content="https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/"><meta property="og:site_name" content="丢哥"><meta property="og:title" content="第十一章：grpc 协议解包过程全剖析"><meta property="og:description" content="http2 协议帧格式 我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="lessons"><meta property="article:published_time" content="2019-11-11T00:00:00+08:00"><meta property="article:modified_time" content="2019-11-11T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第十一章：grpc 协议解包过程全剖析"><meta name=twitter:description content="http2 协议帧格式
我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"教程","item":"https://diu.life/lessons/"},{"@type":"ListItem","position":2,"name":"gRPC 源码阅读","item":"https://diu.life/lessons/grpc-read/"},{"@type":"ListItem","position":3,"name":"第十一章：grpc 协议解包过程全剖析","item":"https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第十一章：grpc 协议解包过程全剖析","name":"第十一章：grpc 协议解包过程全剖析","description":"http2 协议帧格式 我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。\n","keywords":[],"articleBody":"http2 协议帧格式 我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。\n我们知道 grpc 传输层是基于 http2 协议规范，所以我们先要了解 http2 协议帧的格式。http 2 协议帧格式如下：\nFrame Format All frames begin with a fixed 9-octet header followed by a variable-length payload. +-----------------------------------------------+ | Length (24) | +---------------+---------------+---------------+ | Type (8) | Flags (8) | +-+-------------+---------------+-------------------------------+ |R| Stream Identifier (31) | +=+=============================================================+ | Frame Payload (0...) ... +---------------------------------------------------------------+ 对于一个网络包而言，首先要知道这个包的格式，然后才能按照约定的格式解析出这个包。那么 grpc 的包是什么样的格式呢？ 看了源码后，先直接揭晓出来，它其实是这样的\nhttp 帧格式为：length (3 byte) + type(1 byte) + flag (1 byte) + R (1 bit) + stream identifier (31 bit) + paypoad，payload 是消息具体内容\n前 9 个字节是 http 包头，length 表示消息长度，type 表示 http 帧的类型，http 一共规定了 10 种帧类型：\nHEADERS帧 头信息，对应于HTTP HEADER DATA帧 对应于HTTP Response Body PRIORITY帧 用于调整流的优先级 RST_STREAM帧 流终止帧，用于中断资源的传输 SETTINGS帧 用户客户服务器交流连接配置信息 PUSH_PROMISE帧 服务器向客户端主动推送资源 GOAWAY帧 通知对方断开连接 PING帧 心跳帧，检测往返时间和连接可用性 WINDOW_UPDATE帧 调整帧大小 CONTINUATION帧 HEADERS太大时的续帧 flag 表示标志位，http 一共三种标志位：\nEND_STREAM 流结束标志，表示当前帧是流的最后一个帧 END_HEADERS 头结束表示，表示当前帧是头信息的最后一个帧 PADDED 填充标志，在数据Payload里填充无用信息，用于干扰信道监听 R 是 1bit 的保留位，stream identifier 是流 id，http 会为每一个数据流分配一个 id\n具体可以参考：http frame\n解析 http 帧头 回到 examples 目录的 helloworld 目录， 在 server main 函数中跟踪 s.Serve 方法： s.Serve() ——\u003e s.handleRawConn(rawConn) ——\u003e s.serveStreams(st)\n来看一下 serveStreams 这个方法\nfunc (s *Server) serveStreams(st transport.ServerTransport) { defer st.Close() var wg sync.WaitGroup st.HandleStreams(func(stream *transport.Stream) { wg.Add(1) go func() { defer wg.Done() s.handleStream(st, stream, s.traceInfo(st, stream)) }() }, func(ctx context.Context, method string) context.Context { if !EnableTracing { return ctx } tr := trace.New(\"grpc.Recv.\"+methodFamily(method), method) return trace.NewContext(ctx, tr) }) wg.Wait() } 这里调用了 transport 的 HandleStreams 方法， 这个方法就是 http 帧的处理的具体实现。它的底层直接调用的 http2 包的 ReadFrame 方法去读取一个 http 帧数据。\ntype framer struct { writer *bufWriter fr *http2.Framer } func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) { defer close(t.readerDone) for { frame, err := t.framer.fr.ReadFrame() atomic.StoreUint32(\u0026t.activity, 1) ... switch frame := frame.(type) { case *http2.MetaHeadersFrame: if t.operateHeaders(frame, handle, traceCtx) { t.Close() break } case *http2.DataFrame: t.handleData(frame) case *http2.RSTStreamFrame: t.handleRSTStream(frame) case *http2.SettingsFrame: t.handleSettings(frame) case *http2.PingFrame: t.handlePing(frame) case *http2.WindowUpdateFrame: t.handleWindowUpdate(frame) case *http2.GoAwayFrame: // TODO: Handle GoAway from the client appropriately. default: errorf(\"transport: http2Server.HandleStreams found unhandled frame type %v.\", frame) } } } 通过 http2 包的 ReadFrame 直接读取出一个帧的数据。\nfunc (fr *Framer) ReadFrame() (Frame, error) { fr.errDetail = nil if fr.lastFrame != nil { fr.lastFrame.invalidate() } fh, err := readFrameHeader(fr.headerBuf[:], fr.r) if err != nil { return nil, err } if fh.Length \u003e fr.maxReadSize { return nil, ErrFrameTooLarge } payload := fr.getReadBuf(fh.Length) if _, err := io.ReadFull(fr.r, payload); err != nil { return nil, err } f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload) if err != nil { if ce, ok := err.(connError); ok { return nil, fr.connError(ce.Code, ce.Reason) } return nil, err } if err := fr.checkFrameOrder(f); err != nil { return nil, err } if fr.logReads { fr.debugReadLoggerf(\"http2: Framer %p: read %v\", fr, summarizeFrame(f)) } if fh.Type == FrameHeaders \u0026\u0026 fr.ReadMetaHeaders != nil { return fr.readMetaFrame(f.(*HeadersFrame)) } return f, nil } fh, err := readFrameHeader(fr.headerBuf[:], fr.r) 这一行代码读取了 http 的包头数据，我们来看一下 headerBuf 的长度，发现果然是 9 个字节。\nconst frameHeaderLen = 9 func readFrameHeader(buf []byte, r io.Reader) (FrameHeader, error) { _, err := io.ReadFull(r, buf[:frameHeaderLen]) if err != nil { return FrameHeader{}, err } return FrameHeader{ Length: (uint32(buf[0])\u003c\u003c16 | uint32(buf[1])\u003c\u003c8 | uint32(buf[2])), Type: FrameType(buf[3]), Flags: Flags(buf[4]), StreamID: binary.BigEndian.Uint32(buf[5:]) \u0026 (1\u003c\u003c31 - 1), valid: true, }, nil } 解析业务数据 经过上面的过程，我们终于将 http 包头给读出来了。前面说到了，读出 http 包体之后，还需要解析 grpc 协议头。那这部分是怎么去解析的呢？\n回到 http2 读帧的部分，当发现帧的格式是 MetaHeadersFrame，也就是第一个帧时，会调用 operateHeaders 方法\ncase *http2.MetaHeadersFrame: if t.operateHeaders(frame, handle, traceCtx) { t.Close() break } 看一下 operateHeaders ，里面会去调用 handle(s) ， 这个handle 其实是 之前 s.Serve() ——\u003e s.handleRawConn(rawConn) ——\u003e s.serveStreams(st) 这个路径下的 HandleStreams 方法传入的，也就是会去调用 handleStream 这个方法\nst.HandleStreams(func(stream *transport.Stream) { wg.Add(1) go func() { defer wg.Done() s.handleStream(st, stream, s.traceInfo(st, stream)) }() }, func(ctx context.Context, method string) context.Context { if !EnableTracing { return ctx } tr := trace.New(\"grpc.Recv.\"+methodFamily(method), method) return trace.NewContext(ctx, tr) }) s.handleStream(st, stream, s.traceInfo(st, stream)) ——\u003e s.processUnaryRPC(t, stream, srv, md, trInfo) ———\u003e d, err := recvAndDecompress(\u0026parser{r: stream}, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp) ，进入 recvAndDecompress 这个函数，里面调用了\npf, d, err := p.recvMsg(maxReceiveMessageSize) 进入 recvMsg，发现它就是解析 grpc 协议 的函数，先把协议头读出来，用了 5 个字节。从协议头中得知协议体消息的长度，然后用一个相应长度的 byte 数组把协议体读出来\ntype parser struct { r io.Reader header [5]byte } func (p *parser) recvMsg(maxReceiveMessageSize int) (pf payloadFormat, msg []byte, err error) { if _, err := p.r.Read(p.header[:]); err != nil { return 0, nil, err } pf = payloadFormat(p.header[0]) length := binary.BigEndian.Uint32(p.header[1:]) ... msg = make([]byte, int(length)) if _, err := p.r.Read(msg); err != nil { if err == io.EOF { err = io.ErrUnexpectedEOF } return 0, nil, err } return pf, msg, nil } 继续回到这个图，前面说到了 grpc 协议头是 5个字节。 compressed-flag 表示是否压缩，值为 1 是压缩消息体数据，0 不压缩。 length 表示消息体数据长度。现在终于知道了这个数据结构的由来！\n读取出来的数据是二进制的，读出来原数据之后呢，我们就可以针对相应的数据做解包操作了。这里可以参考我的另一篇文章 ：10-grpc 协议编解码器\n","wordCount":"1847","inLanguage":"zh","datePublished":"2019-11-11T00:00:00+08:00","dateModified":"2019-11-11T00:00:00+08:00","author":{"@type":"Person","name":"丢哥"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/"},"publisher":{"@type":"Organization","name":"丢哥","logo":{"@type":"ImageObject","url":"https://diu.life/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diu.life/ accesskey=h title="丢哥 (Alt + H)">丢哥</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diu.life/ title=首页><span>首页</span></a></li><li><a href=https://diu.life/posts/ title=文章><span>文章</span></a></li><li><a href=https://diu.life/projects/ title=独立开发><span>独立开发</span></a></li><li><a href=https://diu.life/lessons/ title=教程><span>教程</span></a></li><li><a href=https://diu.life/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><div class=lesson-container><div class=lesson-sidebar><div class=lesson-nav><h3>Grpc-Read 教程</h3><ul class=chapter-list><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-concepts-http2/ class=chapter-link><span class=chapter-title>第一章：grpc concepts & http2</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world/ class=chapter-link><span class=chapter-title>第二章：grpc hello world</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/ class=chapter-link><span class=chapter-title>第三章：grpc hello world server 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/ class=chapter-link><span class=chapter-title>第四章：grpc hello world client 解析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-service-discovery/ class=chapter-link><span class=chapter-title>第五章：grpc 服务发现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-load-balancing/ class=chapter-link><span class=chapter-title>第六章：grpc 负载均衡</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-tls/ class=chapter-link><span class=chapter-title>第七章：grpc 认证鉴权——tls认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-auth-oauth2/ class=chapter-link><span class=chapter-title>第八章：grpc 认证鉴权——oauth2认证</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/ class=chapter-link><span class=chapter-title>第九章：grpc 拦截器实现</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/ class=chapter-link><span class=chapter-title>第十章：grpc 协议编解码器</span></a></li><li class="chapter-item active"><a href=https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/ class=chapter-link><span class=chapter-title>第十一章：grpc 协议解包过程全剖析</span></a></li><li class=chapter-item><a href=https://diu.life/lessons/grpc-read/grpc-data-flow/ class=chapter-link><span class=chapter-title>第十二章：grpc 数据流转</span></a></li></ul></div></div><div class=lesson-content><article class=post-single><header class=post-header><h1 class=post-title>第十一章：grpc 协议解包过程全剖析</h1><div class=post-meta><time datetime=2019-11-11T00:00:00+08:00>2019-11-11</time></div></header><div class=post-content><h3 id=http2-协议帧格式>http2 协议帧格式</h3><p>我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。</p><p>我们知道 grpc 传输层是基于 http2 协议规范，所以我们先要了解 http2 协议帧的格式。http 2 协议帧格式如下：</p><pre tabindex=0><code class=language-http2 data-lang=http2>Frame Format
All frames begin with a fixed 9-octet header followed by a variable-length payload.

 +-----------------------------------------------+
 |                 Length (24)                   |
 +---------------+---------------+---------------+
 |   Type (8)    |   Flags (8)   |
 +-+-------------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +=+=============================================================+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
</code></pre><p>对于一个网络包而言，首先要知道这个包的格式，然后才能按照约定的格式解析出这个包。那么 grpc 的包是什么样的格式呢？ 看了源码后，先直接揭晓出来，它其实是这样的</p><p><img loading=lazy src=https://images.xiaozhuanlan.com/photo/2019/ad81643a987d5ae267f3ea2dc4cd3434.png></p><p>http 帧格式为：length (3 byte) + type(1 byte) + flag (1 byte) + R (1 bit) + stream identifier (31 bit) + paypoad，payload 是消息具体内容</p><p>前 9 个字节是 http 包头，length 表示消息长度，type 表示 http 帧的类型，http 一共规定了 10 种帧类型：</p><ul><li>HEADERS帧 头信息，对应于HTTP HEADER</li><li>DATA帧 对应于HTTP Response Body</li><li>PRIORITY帧 用于调整流的优先级</li><li>RST_STREAM帧 流终止帧，用于中断资源的传输</li><li>SETTINGS帧 用户客户服务器交流连接配置信息</li><li>PUSH_PROMISE帧 服务器向客户端主动推送资源</li><li>GOAWAY帧 通知对方断开连接</li><li>PING帧 心跳帧，检测往返时间和连接可用性</li><li>WINDOW_UPDATE帧 调整帧大小</li><li>CONTINUATION帧 HEADERS太大时的续帧</li></ul><p>flag 表示标志位，http 一共三种标志位：</p><ul><li>END_STREAM 流结束标志，表示当前帧是流的最后一个帧</li><li>END_HEADERS 头结束表示，表示当前帧是头信息的最后一个帧</li><li>PADDED 填充标志，在数据Payload里填充无用信息，用于干扰信道监听</li></ul><p>R 是 1bit 的保留位，stream identifier 是流 id，http 会为每一个数据流分配一个 id</p><p>具体可以参考：<a href=https://http2.github.io/http2-spec/#FramingLayer>http frame</a></p><h3 id=解析-http-帧头>解析 http 帧头</h3><p>回到 examples 目录的 helloworld 目录， 在 server main 函数中跟踪 s.Serve 方法： s.Serve() ——> s.handleRawConn(rawConn) ——> s.serveStreams(st)</p><p>来看一下 serveStreams 这个方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>serveStreams</span><span class=p>(</span><span class=nx>st</span> <span class=nx>transport</span><span class=p>.</span><span class=nx>ServerTransport</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>st</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>	<span class=nx>st</span><span class=p>.</span><span class=nf>HandleStreams</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>stream</span> <span class=o>*</span><span class=nx>transport</span><span class=p>.</span><span class=nx>Stream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nx>s</span><span class=p>.</span><span class=nf>handleStream</span><span class=p>(</span><span class=nx>st</span><span class=p>,</span> <span class=nx>stream</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nf>traceInfo</span><span class=p>(</span><span class=nx>st</span><span class=p>,</span> <span class=nx>stream</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>method</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>EnableTracing</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>ctx</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>tr</span> <span class=o>:=</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;grpc.Recv.&#34;</span><span class=o>+</span><span class=nf>methodFamily</span><span class=p>(</span><span class=nx>method</span><span class=p>),</span> <span class=nx>method</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>NewContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>tr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里调用了 transport 的 HandleStreams 方法， 这个方法就是 http 帧的处理的具体实现。它的底层直接调用的 http2 包的 ReadFrame 方法去读取一个 http 帧数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>framer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>writer</span> <span class=o>*</span><span class=nx>bufWriter</span>
</span></span><span class=line><span class=cl>	<span class=nx>fr</span>     <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>Framer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>http2Server</span><span class=p>)</span> <span class=nf>HandleStreams</span><span class=p>(</span><span class=nx>handle</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>Stream</span><span class=p>),</span> <span class=nx>traceCtx</span> <span class=kd>func</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>readerDone</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>frame</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nx>framer</span><span class=p>.</span><span class=nx>fr</span><span class=p>.</span><span class=nf>ReadFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreUint32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>t</span><span class=p>.</span><span class=nx>activity</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>frame</span> <span class=o>:=</span> <span class=nx>frame</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>MetaHeadersFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>operateHeaders</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>handle</span><span class=p>,</span> <span class=nx>traceCtx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>t</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>DataFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>handleData</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>RSTStreamFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>handleRSTStream</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>SettingsFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>handleSettings</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>PingFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>handlePing</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>WindowUpdateFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>handleWindowUpdate</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>GoAwayFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1>// TODO: Handle GoAway from the client appropriately.</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nf>errorf</span><span class=p>(</span><span class=s>&#34;transport: http2Server.HandleStreams found unhandled frame type %v.&#34;</span><span class=p>,</span> <span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过 http2 包的 ReadFrame 直接读取出一个帧的数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>fr</span> <span class=o>*</span><span class=nx>Framer</span><span class=p>)</span> <span class=nf>ReadFrame</span><span class=p>()</span> <span class=p>(</span><span class=nx>Frame</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fr</span><span class=p>.</span><span class=nx>errDetail</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fr</span><span class=p>.</span><span class=nx>lastFrame</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fr</span><span class=p>.</span><span class=nx>lastFrame</span><span class=p>.</span><span class=nf>invalidate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fh</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>readFrameHeader</span><span class=p>(</span><span class=nx>fr</span><span class=p>.</span><span class=nx>headerBuf</span><span class=p>[:],</span> <span class=nx>fr</span><span class=p>.</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fh</span><span class=p>.</span><span class=nx>Length</span> <span class=p>&gt;</span> <span class=nx>fr</span><span class=p>.</span><span class=nx>maxReadSize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ErrFrameTooLarge</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>payload</span> <span class=o>:=</span> <span class=nx>fr</span><span class=p>.</span><span class=nf>getReadBuf</span><span class=p>(</span><span class=nx>fh</span><span class=p>.</span><span class=nx>Length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadFull</span><span class=p>(</span><span class=nx>fr</span><span class=p>.</span><span class=nx>r</span><span class=p>,</span> <span class=nx>payload</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>typeFrameParser</span><span class=p>(</span><span class=nx>fh</span><span class=p>.</span><span class=nx>Type</span><span class=p>)(</span><span class=nx>fr</span><span class=p>.</span><span class=nx>frameCache</span><span class=p>,</span> <span class=nx>fh</span><span class=p>,</span> <span class=nx>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ce</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>connError</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fr</span><span class=p>.</span><span class=nf>connError</span><span class=p>(</span><span class=nx>ce</span><span class=p>.</span><span class=nx>Code</span><span class=p>,</span> <span class=nx>ce</span><span class=p>.</span><span class=nx>Reason</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fr</span><span class=p>.</span><span class=nf>checkFrameOrder</span><span class=p>(</span><span class=nx>f</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fr</span><span class=p>.</span><span class=nx>logReads</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fr</span><span class=p>.</span><span class=nf>debugReadLoggerf</span><span class=p>(</span><span class=s>&#34;http2: Framer %p: read %v&#34;</span><span class=p>,</span> <span class=nx>fr</span><span class=p>,</span> <span class=nf>summarizeFrame</span><span class=p>(</span><span class=nx>f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>fh</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>FrameHeaders</span> <span class=o>&amp;&amp;</span> <span class=nx>fr</span><span class=p>.</span><span class=nx>ReadMetaHeaders</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fr</span><span class=p>.</span><span class=nf>readMetaFrame</span><span class=p>(</span><span class=nx>f</span><span class=p>.(</span><span class=o>*</span><span class=nx>HeadersFrame</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>f</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>fh, err := readFrameHeader(fr.headerBuf[:], fr.r) 这一行代码读取了 http 的包头数据，我们来看一下 headerBuf 的长度，发现果然是 9 个字节。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>frameHeaderLen</span> <span class=p>=</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>readFrameHeader</span><span class=p>(</span><span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>(</span><span class=nx>FrameHeader</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadFull</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>buf</span><span class=p>[:</span><span class=nx>frameHeaderLen</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>FrameHeader</span><span class=p>{},</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>FrameHeader</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Length</span><span class=p>:</span>   <span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>&lt;&lt;</span><span class=mi>16</span> <span class=p>|</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>&lt;&lt;</span><span class=mi>8</span> <span class=p>|</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>2</span><span class=p>])),</span>
</span></span><span class=line><span class=cl>		<span class=nx>Type</span><span class=p>:</span>     <span class=nf>FrameType</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>3</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>		<span class=nx>Flags</span><span class=p>:</span>    <span class=nf>Flags</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>4</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>		<span class=nx>StreamID</span><span class=p>:</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>Uint32</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=mi>5</span><span class=p>:])</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>31</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>valid</span><span class=p>:</span>    <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=解析业务数据>解析业务数据</h3><p>经过上面的过程，我们终于将 http 包头给读出来了。前面说到了，读出 http 包体之后，还需要解析 grpc 协议头。那这部分是怎么去解析的呢？</p><p>回到 http2 读帧的部分，当发现帧的格式是 MetaHeadersFrame，也就是第一个帧时，会调用 operateHeaders 方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>case</span> <span class=o>*</span><span class=nx>http2</span><span class=p>.</span><span class=nx>MetaHeadersFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>operateHeaders</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>handle</span><span class=p>,</span> <span class=nx>traceCtx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>t</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span></code></pre></div><p>看一下 operateHeaders ，里面会去调用 handle(s) ， 这个handle 其实是 之前 s.Serve() ——> s.handleRawConn(rawConn) ——> s.serveStreams(st) 这个路径下的 HandleStreams 方法传入的，也就是会去调用 handleStream 这个方法</p><pre tabindex=0><code>st.HandleStreams(func(stream *transport.Stream) {
		wg.Add(1)
		go func() {
			defer wg.Done()
			s.handleStream(st, stream, s.traceInfo(st, stream))
		}()
	}, func(ctx context.Context, method string) context.Context {
		if !EnableTracing {
			return ctx
		}
		tr := trace.New(&#34;grpc.Recv.&#34;+methodFamily(method), method)
		return trace.NewContext(ctx, tr)
	})
</code></pre><p>s.handleStream(st, stream, s.traceInfo(st, stream)) ——> s.processUnaryRPC(t, stream, srv, md, trInfo) ———> d, err := recvAndDecompress(&amp;parser{r: stream}, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp) ，进入 recvAndDecompress 这个函数，里面调用了</p><pre tabindex=0><code>	pf, d, err := p.recvMsg(maxReceiveMessageSize)
</code></pre><p>进入 recvMsg，发现它就是解析 grpc 协议 的函数，先把协议头读出来，用了 5 个字节。从协议头中得知协议体消息的长度，然后用一个相应长度的 byte 数组把协议体读出来</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>parser</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>header</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>parser</span><span class=p>)</span> <span class=nf>recvMsg</span><span class=p>(</span><span class=nx>maxReceiveMessageSize</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>pf</span> <span class=nx>payloadFormat</span><span class=p>,</span> <span class=nx>msg</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>r</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[:]);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>pf</span> <span class=p>=</span> <span class=nf>payloadFormat</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=nx>length</span> <span class=o>:=</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>Uint32</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>header</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>...</span> 
</span></span><span class=line><span class=cl>	<span class=nx>msg</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>length</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>r</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>msg</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrUnexpectedEOF</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>pf</span><span class=p>,</span> <span class=nx>msg</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>继续回到这个图，前面说到了 grpc 协议头是 5个字节。
<img alt="grpc protocol unpacking analysis" loading=lazy src=/images/grpc-read/11-1.jpg>
compressed-flag 表示是否压缩，值为 1 是压缩消息体数据，0 不压缩。
length 表示消息体数据长度。现在终于知道了这个数据结构的由来！</p><p>读取出来的数据是二进制的，读出来原数据之后呢，我们就可以针对相应的数据做解包操作了。这里可以参考我的另一篇文章 ：<a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/>10-grpc 协议编解码器</a></p></div><div class=lesson-navigation><div class=nav-buttons><a href=https://diu.life/lessons/grpc-read/grpc-protocol-codec/ class="nav-btn prev-btn"><span>← 上一章</span>
<span class=nav-title>第十章：grpc 协议编解码器</span>
</a><a href=https://diu.life/lessons/grpc-read/grpc-data-flow/ class="nav-btn next-btn"><span>下一章 →</span>
<span class=nav-title>第十二章：grpc 数据流转</span></a></div></div></article></div></div><style>.main{max-width:100% !important;padding:0 !important}.lesson-container{display:flex;min-height:calc(100vh - 60px);gap:0;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:320px;background:linear-gradient(180deg,#ffffff 0%,#f8f9fa 100%);border-right:none;box-shadow:2px 0 20px rgba(0,0,0,8%);position:sticky;top:60px;height:calc(100vh - 60px);overflow-y:auto;padding:30px 25px;z-index:10}.lesson-nav h3{margin:0 0 30px;color:#2c3e50;font-size:1.4em;font-weight:700;text-align:center;padding-bottom:15px;border-bottom:2px solid #e3f2fd;position:relative}.lesson-nav h3::after{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:60px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.chapter-list{list-style:none;padding:0;margin:0}.chapter-item{margin-bottom:12px}.chapter-link{display:block;padding:16px 20px;color:#5a6c7d;text-decoration:none;border-radius:12px;transition:all .3s cubic-bezier(.4,0,.2,1);border:1px solid transparent;background:rgba(255,255,255,.7);backdrop-filter:blur(10px);position:relative;overflow:hidden}.chapter-link::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);transition:left .5s}.chapter-link:hover{background:rgba(255,255,255,.9);color:#2c3e50;transform:translateX(8px);box-shadow:0 8px 25px rgba(0,0,0,.1)}.chapter-link:hover::before{left:100%}.chapter-item.active .chapter-link{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:600;box-shadow:0 10px 30px rgba(102,126,234,.3);transform:translateX(8px)}.chapter-item.active .chapter-link::before{display:none}.chapter-title{font-size:.95em;line-height:1.5;font-weight:500}.lesson-content{flex:1;padding:40px 50px;width:100%;overflow-x:auto;background:rgba(255,255,255,.95);backdrop-filter:blur(20px);margin:20px;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.1);position:relative}.lesson-content::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);border-radius:20px 20px 0 0}.post-single{max-width:100%;margin:0}.post-header{margin-bottom:40px;padding-bottom:20px;border-bottom:1px solid #e8ecef}.post-title{font-size:2.2em;font-weight:800;margin:0 0 15px;color:#2c3e50;line-height:1.3;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.post-meta{color:#7f8c8d;font-size:.95em;font-weight:500}.post-content{line-height:1.8;color:#34495e;font-size:1.05em}.post-content h2{margin-top:50px;margin-bottom:25px;font-size:1.6em;font-weight:700;color:#2c3e50;position:relative;padding-left:20px}.post-content h2::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:4px;height:60%;background:linear-gradient(180deg,#667eea 0%,#764ba2 100%);border-radius:2px}.post-content h3{margin-top:35px;margin-bottom:20px;font-size:1.4em;font-weight:600;color:#2c3e50}.post-content p{margin-bottom:20px;text-align:justify}.post-content ul,.post-content ol{margin-bottom:20px;padding-left:25px}.post-content li{margin-bottom:10px;line-height:1.7}.post-content code{background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);padding:4px 8px;border-radius:6px;font-size:.9em;color:#e83e8c;font-weight:500;border:1px solid #dee2e6}.post-content pre{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);padding:25px;border-radius:12px;overflow-x:auto;margin:30px 0;box-shadow:0 10px 30px rgba(0,0,0,.1);border:1px solid #4a5568}.post-content pre code{background:0 0;padding:0;border-radius:0;color:#a0aec0;border:none}.lesson-navigation{margin-top:60px;padding-top:40px;border-top:2px solid #e8ecef;position:relative}.lesson-navigation::before{content:'';position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:100px;height:2px;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%)}.nav-buttons{display:flex;justify-content:space-between;gap:25px}.nav-btn{display:flex;flex-direction:column;padding:20px 25px;background:linear-gradient(135deg,#ffffff 0%,#f8f9fa 100%);border:2px solid #e9ecef;border-radius:15px;text-decoration:none;color:#2c3e50;transition:all .3s cubic-bezier(.4,0,.2,1);flex:1;max-width:320px;position:relative;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,8%)}.nav-btn::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(102,126,234,.1),transparent);transition:left .6s}.nav-btn:hover{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);border-color:#667eea;color:#fff;transform:translateY(-3px);box-shadow:0 15px 40px rgba(102,126,234,.3)}.nav-btn:hover::before{left:100%}.nav-btn span:first-child{font-size:.95em;color:#7f8c8d;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}.nav-btn:hover span:first-child{color:rgba(255,255,255,.9)}.nav-title{font-weight:600;line-height:1.4;font-size:1.05em}.next-btn{text-align:right}@media(max-width:768px){.lesson-container{flex-direction:column;background:linear-gradient(180deg,#f5f7fa 0%,#c3cfe2 100%)}.lesson-sidebar{width:100%;height:auto;position:static;border-right:none;border-bottom:2px solid #e8ecef;box-shadow:0 2px 15px rgba(0,0,0,.1);padding:25px 20px;margin:0;border-radius:0}.lesson-content{max-width:100%;padding:30px 20px;margin:15px;border-radius:15px}.post-title{font-size:1.8em}.post-content{font-size:1em}.nav-buttons{flex-direction:column;gap:15px}.nav-btn{max-width:100%}.next-btn{text-align:left}.chapter-link:hover,.chapter-item.active .chapter-link{transform:none}}</style></main><footer class=footer><span>&copy; 2021 丢哥 all rights reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>