<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>gRPC 源码阅读 on 丢哥</title><link>https://diu.life/lessons/grpc-read/</link><description>Recent content in gRPC 源码阅读 on 丢哥</description><generator>Hugo -- 0.154.2</generator><language>zh-cn</language><lastBuildDate>Tue, 12 Nov 2019 00:00:00 +0800</lastBuildDate><atom:link href="https://diu.life/lessons/grpc-read/index.xml" rel="self" type="application/rss+xml"/><item><title>第十二章：grpc 数据流转</title><link>https://diu.life/lessons/grpc-read/grpc-data-flow/</link><pubDate>Tue, 12 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-data-flow/</guid><description>&lt;h1 id="grpc-数据流转"&gt;grpc 数据流转&lt;/h1&gt;
&lt;p&gt;阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 &lt;a href="https://diu.life/lessons/grpc-read/grpc-protocol-codec/"&gt;《10 - grpc 协议编解码器》&lt;/a&gt; 和 &lt;a href="https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/"&gt;《11 - grpc 协议解包过程全剖析》&lt;/a&gt;&lt;/p&gt;</description></item><item><title>第十一章：grpc 协议解包过程全剖析</title><link>https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/</link><pubDate>Mon, 11 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-protocol-unpacking-analysis/</guid><description>&lt;h3 id="http2-协议帧格式"&gt;http2 协议帧格式&lt;/h3&gt;
&lt;p&gt;我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。&lt;/p&gt;</description></item><item><title>第十章：grpc 协议编解码器</title><link>https://diu.life/lessons/grpc-read/grpc-protocol-codec/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-protocol-codec/</guid><description>&lt;h3 id="协议编解码器"&gt;协议编解码器&lt;/h3&gt;
&lt;p&gt;一般的协议都会包括协议头和协议体，对于业务而言，一般只关心需要发送的业务数据。所以，协议头的内容一般是框架自动帮忙填充。将业务数据包装成指定协议格式的数据包就是编码的过程，从指定协议格式中的数据包中取出业务数据的过程就是解码的过程。&lt;/p&gt;</description></item><item><title>第九章：grpc 拦截器实现</title><link>https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/</link><pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-interceptor-implementation/</guid><description>&lt;h2 id="grpc-源码解读--从-0-到-1-实现拦截器"&gt;grpc 源码解读 —— 从 0 到 1 实现拦截器&lt;/h2&gt;
&lt;p&gt;拦截器，通俗点说，就是在执行一段代码之前或者之后，去执行另外一段代码。
拦截器在业界知名框架中的运用非常普遍。包括 Spring 、Grpc 等框架中都有拦截器的实现。接下来我们想办法从 0 到 1 自己实现一个拦截器。以下的实现主要使用 go 语言讲解。&lt;/p&gt;</description></item><item><title>第八章：grpc 认证鉴权——oauth2认证</title><link>https://diu.life/lessons/grpc-read/grpc-auth-oauth2/</link><pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-auth-oauth2/</guid><description>&lt;h2 id="grpc-认证鉴权--oauth2"&gt;grpc 认证鉴权 —— oauth2&lt;/h2&gt;
&lt;p&gt;前面我们说了 tls 认证，tls 保证了 client 和 server 通信的安全性，但是无法做到接口级别的权限控制。例如有 A、B、C、D 四个系统，存在下面两个场景：
1、我们希望 A 可以访问 B、C 系统，但是不能访问 D 系统
2、B 系统提供了 b1、b2、b3 三个接口，我们希望 A 系统可以访问 b1、b2 接口，但是不能访问 b3 接口。
此时 tls 认证肯定是无法实现上面两个诉求的，对于这两个场景，grpc 提供了 oauth2 的认证方式。对 oauth2 不了解的同学可以参考 &lt;a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html"&gt;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&lt;/a&gt;&lt;/p&gt;</description></item><item><title>第七章：grpc 认证鉴权——tls认证</title><link>https://diu.life/lessons/grpc-read/grpc-auth-tls/</link><pubDate>Thu, 07 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-auth-tls/</guid><description>&lt;h2 id="grpc-认证鉴权"&gt;grpc 认证鉴权&lt;/h2&gt;
&lt;p&gt;在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。&lt;/p&gt;
&lt;h3 id="1单体模式下的认证鉴权"&gt;1、单体模式下的认证鉴权&lt;/h3&gt;
&lt;p&gt;在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。&lt;/p&gt;</description></item><item><title>第六章：grpc 负载均衡</title><link>https://diu.life/lessons/grpc-read/grpc-load-balancing/</link><pubDate>Wed, 06 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-load-balancing/</guid><description>&lt;h3 id="grpc负载均衡"&gt;grpc负载均衡&lt;/h3&gt;
&lt;h4 id="负载均衡流程"&gt;负载均衡流程&lt;/h4&gt;
&lt;p&gt;grpc 官方的 doc 中介绍了，grpc 的负载均衡是基于一次请求而不是一次连接的。也就是说，假如所有的请求都来自同一个客户端的连接，这些请求还是会被均衡到所有服务器。&lt;/p&gt;</description></item><item><title>第五章：grpc 服务发现</title><link>https://diu.life/lessons/grpc-read/grpc-service-discovery/</link><pubDate>Tue, 05 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-service-discovery/</guid><description>&lt;h3 id="服务发现"&gt;服务发现&lt;/h3&gt;
&lt;p&gt;在了解 grpc 服务发现之前，我们先来了解一下服务发现的路由方式。一般来说，我们有客户端路由和代理层路由两种方式。&lt;/p&gt;
&lt;h4 id="客户端路由"&gt;客户端路由&lt;/h4&gt;
&lt;p&gt;客户端路由模式，也就是调用方负责获取被调用方的地址信息，并使用相应的负载均衡算法发起请求。调用方访问服务注册服务，获取对应的服务 IP 地址和端口，可能还包括对应的服务负载信息（负载均衡算法、服务实例权重等）。调用方通过负载均衡算法选取其中一个发起请求。如下：&lt;/p&gt;</description></item><item><title>第四章：grpc hello world client 解析</title><link>https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/</link><pubDate>Mon, 04 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-hello-world-client-analysis/</guid><description>&lt;h3 id="grpc-hello-world--client-解析"&gt;grpc hello world client 解析&lt;/h3&gt;
&lt;p&gt;上一节我们介绍了 grpc 输出 hello world 过程中 server 监听和处理请求的过程。这一节中我们将介绍 client 发出请求的过程。&lt;/p&gt;
&lt;p&gt;来先看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
// Set up a connection to the server.
conn, err := grpc.Dial(address, grpc.WithInsecure())
if err != nil {
log.Fatalf(&amp;quot;did not connect: %v&amp;quot;, err)
}
defer conn.Close()
c := pb.NewGreeterClient(conn)
// Contact the server and print out its response.
name := defaultName
if len(os.Args) &amp;gt; 1 {
name = os.Args[1]
}
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()
r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name})
if err != nil {
log.Fatalf(&amp;quot;could not greet: %v&amp;quot;, err)
}
log.Printf(&amp;quot;Greeting: %s&amp;quot;, r.Message)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 client 的建立也可以大致分为 3 步：&lt;/p&gt;</description></item><item><title>第三章：grpc hello world server 解析</title><link>https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/</link><pubDate>Sun, 03 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-hello-world-server-analysis/</guid><description>&lt;h3 id="grpc-hello-world-server-解析"&gt;grpc hello world server 解析&lt;/h3&gt;
&lt;p&gt;我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&amp;hellip;&amp;hellip;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。&lt;/p&gt;</description></item><item><title>第二章：grpc hello world</title><link>https://diu.life/lessons/grpc-read/grpc-hello-world/</link><pubDate>Sat, 02 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-hello-world/</guid><description>&lt;h3 id="grpc-quick-start"&gt;grpc quick start&lt;/h3&gt;
&lt;p&gt;我们分析 go 版本的 grpc 实现，所以这里主要讲解 grpc-go 的安装和使用&lt;/p&gt;
&lt;h4 id="1安装"&gt;1、安装&lt;/h4&gt;
&lt;p&gt;go 语言版本的 grpc 安装需要 1.6 以上的 go 版本，所以你需要先执行 go version 查看 go 版本，假如版本低于 1.6 则需要先升级。&lt;/p&gt;</description></item><item><title>第一章：grpc concepts &amp; http2</title><link>https://diu.life/lessons/grpc-read/grpc-concepts-http2/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate><guid>https://diu.life/lessons/grpc-read/grpc-concepts-http2/</guid><description>&lt;h3 id="写在前面"&gt;写在前面&lt;/h3&gt;
&lt;h4 id="grpc-介绍"&gt;grpc 介绍&lt;/h4&gt;
&lt;p&gt;grpc 是 google 开源的一款高性能的 rpc 框架。github 上介绍如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;市面上的 rpc 框架数不胜数，包括 alibaba dubbo 和微博的 motan 等。grpc 能够在众多的框架中脱颖而出是跟其高性能是密切相关的。&lt;/p&gt;</description></item></channel></rss>