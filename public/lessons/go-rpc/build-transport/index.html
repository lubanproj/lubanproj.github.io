<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>第五章：框架搭建 —— transport | 丢哥</title>
<meta name="keywords" content="">
<meta name="description" content="前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。">
<meta name="author" content="丢哥">
<link rel="canonical" href="https://diu.life/lessons/go-rpc/build-transport/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://diu.life/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://diu.life/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://diu.life/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://diu.life/apple-touch-icon.png">
<link rel="mask-icon" href="https://diu.life/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://diu.life/lessons/go-rpc/build-transport/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2499390968830075"
     crossorigin="anonymous"></script><style>
.footer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
    text-align: center;
}

.footer-links {
    font-size: 0.9em;
    opacity: 0.8;
    white-space: nowrap;
}

.footer-links a {
    color: inherit;
    text-decoration: none;
    margin: 0 5px;
}

.footer-links a:hover {
    text-decoration: underline;
}

.footer-links a:first-child {
    margin-left: 0;
}

.footer-links a:last-child {
    margin-right: 0;
}

@media (max-width: 600px) {
    .footer-content {
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    
    .footer-copyright {
        text-align: center;
    }
}
</style><meta property="og:url" content="https://diu.life/lessons/go-rpc/build-transport/">
  <meta property="og:site_name" content="丢哥">
  <meta property="og:title" content="第五章：框架搭建 —— transport">
  <meta property="og:description" content="前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="lessons">
    <meta property="article:published_time" content="2020-02-05T00:00:00+08:00">
    <meta property="article:modified_time" content="2020-02-05T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第五章：框架搭建 —— transport">
<meta name="twitter:description" content="前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "教程",
      "item": "https://diu.life/lessons/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从 0 到 1 开发一款高性能 RPC 框架",
      "item": "https://diu.life/lessons/go-rpc/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第五章：框架搭建 —— transport",
      "item": "https://diu.life/lessons/go-rpc/build-transport/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第五章：框架搭建 —— transport",
  "name": "第五章：框架搭建 —— transport",
  "description": "前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。\n",
  "keywords": [
    
  ],
  "articleBody": "前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。\n一、transport 接口定义 transport 作为传输层，分为 client 发送方和 server 接收方两种类型，\nserver 传输层主要提供一种监听和处理请求的能力，定义如下：\ntype ServerTransport interface { // monitoring and processing of requests ListenAndServe(context.Context, ...ServerTransportOption) error } ListenAndServe 这个方法就是用来实现请求的监听和处理，所有的 server transport 都需要实现这个方法，同时设计成 interface 接口的方式，主要是为了实现可插拔，支持业务自定义。同时，假如在底层需要支持其他第三方协议，比如需要支持 http 协议，则只要新增一种支持 http 的 transport 即可。\nclient 传输层主要提供一种向下游发送请求的能力，定义如下：\ntype ClientTransport interface { // send requests Send(context.Context, []byte, ...ClientTransportOption) ([]byte, error) } Send 这个方法主要是用来发起请求调用，传参除了上下文 context 之外，还有二进制的请求包 request，返回是一个二进制的完整数据帧。这里设计成 interface 接口的形式，同样是为了可插拔、支持业务自定义。\n二、client/server 通信 我们先从最简单也是最基础的 client/server 通信说起。一个简单 c/s 模型，server 主要功能是监听连接，处理请求，假如使用 tcp 协议实现，代码如下：\nserver.go\nfunc main() { lis, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil { panic(err) } for { conn , err := lis.Accept() defer conn.Close() if err != nil { panic(err) } buffer := make([]byte, 1024) recvNum , err := conn.Read(buffer) msg := string(buffer[:recvNum]) fmt.Println(\"recv from client: \",msg) conn.Write([]byte(\"world\")) } } 此时，client 使用 tcp 协议实现如下：\nclient.go\nfunc main() { conn , err := net.Dial(\"tcp\",\"127.0.0.1:8000\") if err != nil { panic(err) } if _, err := conn.Write([]byte(\"hello\")); err != nil { fmt.Println(err) } buffer := make([]byte, 1024) recvNum , err := conn.Read(buffer) msg := string(buffer[:recvNum]) fmt.Println(\"recv from server: \",msg) } 运行 go run server.go ，然后另起终端运行 go run client.go，server 会收到 client 的 “hello” 请求，cilent 则会收到 server 的 “world” 响应。\n三、问题延伸 现在我们完成了一个基于 tcp 协议的 client/server 通讯服务。我们之前说到了，transport 的核心能力是提供 client 和 server 的底层通信实现。上面的代码已经实现了 client 和 server 互发消息，是不是已经达到我们的目标了呢？慢，我们之前的目标可是高性能，假如深入思考一下，它其实存在以下几个问题：\n1、server 对请求的读写处理是同步的，假如这里同时有两个请求 A、B，只有等请求 A 的读写操作完全完成时，才能进行请求 B 的读写操作，这无疑产生了很严重的等待时间浪费。\n2、server 每次监听到一个请求都会创建一个连接 conn，用 conn 去进行数据的读写，读写完成之后连接 conn 会被关闭，假如同时有成千上万个请求需要处理，每次请求都需要创建和销毁 conn 对象，会造成很大的性能损耗。\n3、server 和 client 每次处理消息时，需要用到一块内存 buffer 用来进行消息读取，这一块内存也会存在频繁创建和销毁问题。\n4、假如 client 或者 server 需要发送的数据包过大，tcp 协议会进行拆包，即把大的数据包拆成多份发送。假如 client 需要发送的数据包过小，tcp 协议底层会进行粘包，即多个数据包合并发送。这种情况下，上面的代码是无法支持的，会出现 client 或者 server 读取到的数据包不完整。\n5、client 每次发送一个数据包都需要创建一个连接 conn，假设请求量过大，可能会出现单机连接数不够用的情况。\n我们一步步来，逐一进行问题解决。\n要解决问题1，这里需要对 server 代码进行改造一下，使 server 的读写异步化，这里其实使用 go 语言的协程机制很方便实现，如下： func main() { lis, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil { panic(err) } for { conn , err := lis.Accept() defer conn.Close() if err != nil { panic(err) } go handleConn(conn) } } func handleConn(conn net.Conn) { buffer := make([]byte, 1024) recvNum , err := conn.Read(buffer) if err != nil { fmt.Println(err) } msg := string(buffer[:recvNum]) fmt.Println(\"recv from client: \",msg) conn.Write([]byte(\"world\")) } 对连接 conn 的处理我们统一放到 handleConn 这个函数中，然后使用 go 关键字，新起一个协程去进行处理，这样就能实现异步化处理请求，避免了同步的时间浪费。\n要解决问题2，我们可以采用长连接的方式，每次 client 和 server 建立连接后，这个连接默认存活，只有在对端关闭连接时，或者连接一直空闲、超过指定时间没有发送消息时，这个连接才关闭。在连接的存活期内，对对端发来的请求进行循环读写，这样就能避免短连接不断创建和关闭造成的性能损耗。这里只需要更改上面的 handleConn 这个方法即可，如下： func handleConn(conn net.Conn) { for { buffer := make([]byte, 1024) recvNum , err := conn.Read(buffer) if err == io.EOF { // client 连接关闭 break } if err != nil { fmt.Println(err) break } msg := string(buffer[:recvNum]) fmt.Println(\"recv from client: \",msg) conn.Write([]byte(\"world\")) } } 使用一个 for 循环对连接循环读取，当遇到 io.EOF 这个错误时，说明 client 已经关闭连接，循环退出，server 关闭这个连接。对空闲连接的检测放在 client 去做，这里先不讲解，放在连接池 pool 的章节进行介绍。\n要解决问题3，我们只需要初始化一块大内存，每次消息读取复用这块内存进行读取即可，比较简单，就不详细介绍了。 要解决问题4，这里需要两个机制，第一是当客户端包过大时，进行循环发包，直到包发完为止。第二是服务端调用 io.ReadFull 函数，保证读取到的包大小刚好等于客户端发过来的包大小，这样就能实现拆包粘包。对 client 代码改动如下： func main() { conn , err := net.Dial(\"tcp\",\"127.0.0.1:8000\") if err != nil { panic(err) } if _, err := conn.Write([]byte(\"hello\")); err != nil { fmt.Println(err) } buffer := make([]byte, 1024) recvNum , err := conn.Read(buffer) msg := string(buffer[:recvNum]) fmt.Println(\"recv from server: \",msg) req := []byte(\"hello\") sendNum := 0 num := 0 // 循环发包 for sendNum \u003c len(req) { num , err = conn.Write(req[sendNum:]) if err != nil { fmt.Println(err) break } sendNum += num } recvNum , err = conn.Read(buffer) msg = string(buffer[:recvNum]) fmt.Println(\"recv from server: \",msg) } 同时，改动 server 的 handleConn 方法，使用 io.ReadFull 进行包读取，如下：\nfunc handleConn(conn net.Conn) { for { buffer := make([]byte, 5) // 使用 io.ReadFull 进行包读取 recvNum , err := io.ReadFull(conn,buffer) if err == io.EOF { // client 连接关闭 break } if err != nil { fmt.Println(err) break } msg := string(buffer[:recvNum]) fmt.Println(\"recv from client: \",msg) conn.Write([]byte(\"world\")) } } 这里需要注意的是假如包的大小没有达到指定的 buffer 大小， io.ReadFull 会在这里进行阻塞，一直等到读取完 buffer 大小的包然后再返回，所以这里需要提前知道包的长度，包的长度会在我们自定义协议的协议头里面可以获取到。\n要解决问题 5，我们可以采用连接池的方式进行连接复用，这里在讲解连接池 pool 的时候会详细讲解，这里就不进行赘述。 四、对 udp 请求的处理 udp 请求跟 tcp 请求不同，udp 是无状态的协议。所以没有拆包粘包、长连接这些问题。因为 udp 的包最大不能超过 64 k，所以对 udp 的处理的原理就是 server 分配一块 64k 的内存，去进行包的接收，然后把响应数据发给对端，其他过程跟 tcp 类似，这里就不进行详细介绍，详情可以参考：transport\n五、与其他组件的交互 由于 client 请求需要向一个指定的 server ip 地址去发送消息，client 调用的时候可能是设置了服务名或者域名。那么首先要跟服务发现模块 resolver 交互，获取后端服务的地址列表，然后再根据客户端设置的负载均衡策略（轮询、随机、加权轮询、一致性哈希等），通过负载均衡算法得到一个 ip 地址。由于引入了连接池 pool 实现了客户端连接复用，所以每次请求需要通过连接池 pool 去获取一个连接 conn。同时，由于每次发送的包是一个附带了协议信息的完整消息，所以这里每次发包，需要调用 codec 的 encode 方法进行打包，每次收包，需要调用 codec 的 decode 方法进行解包。\n所以 transport 这里，虽然是底层模块，但其实跟其他组件也是密不可分的，这些组件会在后续一一介绍。结合这些组件的完整代码可以参考：\nclient_transport\nserver_transport\n小结 这一章主要介绍了传输层 transport 的实现，从一个简单的 client/server 模型，到一个高性能的组件，再通过其他组件的交互，共同实现了一个高性能、高可用的 transport 组件。\n",
  "wordCount" : "2686",
  "inLanguage": "zh",
  "datePublished": "2020-02-05T00:00:00+08:00",
  "dateModified": "2020-02-05T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "丢哥"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://diu.life/lessons/go-rpc/build-transport/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "丢哥",
    "logo": {
      "@type": "ImageObject",
      "url": "https://diu.life/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://diu.life/" accesskey="h" title="丢哥 (Alt + H)">丢哥</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://diu.life/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://diu.life/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://diu.life/projects/" title="独立开发">
                    <span>独立开发</span>
                </a>
            </li>
            <li>
                <a href="https://diu.life/lessons/" title="教程">
                    <span>教程</span>
                </a>
            </li>
            <li>
                <a href="https://diu.life/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<div class="lesson-container">
  
  <div class="lesson-sidebar">
    <div class="lesson-nav">
      <h3>Go-Rpc 教程</h3>
      <ul class="chapter-list">
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/what-is-rpc/" class="chapter-link">
            <span class="chapter-title">第一章：RPC 原理</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/rpc-framework-overview/" class="chapter-link">
            <span class="chapter-title">第二章：RPC 框架概览</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/build-server/" class="chapter-link">
            <span class="chapter-title">第三章：框架搭建 —— server</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/build-client/" class="chapter-link">
            <span class="chapter-title">第四章：框架搭建 —— client</span>
          </a>
        </li>
        <li class="chapter-item active">
          <a href="https://diu.life/lessons/go-rpc/build-transport/" class="chapter-link">
            <span class="chapter-title">第五章：框架搭建 —— transport</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/context-timeout/" class="chapter-link">
            <span class="chapter-title">第六章：超时机制</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/custom-protocol/" class="chapter-link">
            <span class="chapter-title">第七章：自定义协议实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/codec/" class="chapter-link">
            <span class="chapter-title">第八章：协议编解码实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/marshal-and-unmarshal/" class="chapter-link">
            <span class="chapter-title">第九章：序列化实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/log-component/" class="chapter-link">
            <span class="chapter-title">第十章：日志模块实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/connection-pool/" class="chapter-link">
            <span class="chapter-title">第十一章：连接池实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/interceptor/" class="chapter-link">
            <span class="chapter-title">第十二章：拦截器实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/component-interface/" class="chapter-link">
            <span class="chapter-title">第十三章：组件可插拔实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/plugin/" class="chapter-link">
            <span class="chapter-title">第十四章：插件体系实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/service-discovery-selection/" class="chapter-link">
            <span class="chapter-title">第十五章：服务发现原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/service-discovery-implementation/" class="chapter-link">
            <span class="chapter-title">第十六章：服务发现实现 —— consul</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/load-balance-implementation/" class="chapter-link">
            <span class="chapter-title">第十七章：负载均衡实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/tracing-selection/" class="chapter-link">
            <span class="chapter-title">第十八章：分布式链路追踪原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/tracing-implementation/" class="chapter-link">
            <span class="chapter-title">第十九章：分布式链路追踪实现 —— jaeger</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/auth/" class="chapter-link">
            <span class="chapter-title">第二十章：认证鉴权实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/code-generation/" class="chapter-link">
            <span class="chapter-title">第二十一章：代码生成工具实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/performance-test/" class="chapter-link">
            <span class="chapter-title">第二十二章：框架性能测试</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/performance-optimization/" class="chapter-link">
            <span class="chapter-title">第二十三章：框架性能优化</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://diu.life/lessons/go-rpc/summary/" class="chapter-link">
            <span class="chapter-title">第二十四章：总结与展望</span>
          </a>
        </li>
      </ul>
    </div>
  </div>

  
  <div class="lesson-content">
    <article class="post-single">
      <header class="post-header">
        <h1 class="post-title">第五章：框架搭建 —— transport</h1>
        <div class="post-meta">
          <time datetime="2020-02-05T00:00:00&#43;08:00">2020-02-05</time>
        </div>
      </header>

      <div class="post-content">
        <p>前面我们分别介绍了 client 和 server 层的实现，在介绍 client 和 server 时，都涉及到了 transport。transport 就是传输层通信能力的实现。它提供了基于 tcp/udp 等协议的最底层通信能力的实现。接下来我们就来看看它是怎么实现的。</p>
<h3 id="一transport-接口定义">一、transport 接口定义</h3>
<p>transport 作为传输层，分为 client 发送方和 server 接收方两种类型，</p>
<p>server 传输层主要提供一种监听和处理请求的能力，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ServerTransport</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// monitoring and processing of requests</span>
</span></span><span class="line"><span class="cl">   <span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">...</span><span class="nx">ServerTransportOption</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ListenAndServe 这个方法就是用来实现请求的监听和处理，所有的 server transport 都需要实现这个方法，同时设计成 interface 接口的方式，主要是为了实现可插拔，支持业务自定义。同时，假如在底层需要支持其他第三方协议，比如需要支持 http 协议，则只要新增一种支持 http 的 transport 即可。</p>
<p>client 传输层主要提供一种向下游发送请求的能力，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ClientTransport</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// send requests</span>
</span></span><span class="line"><span class="cl">   <span class="nf">Send</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="o">...</span><span class="nx">ClientTransportOption</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Send 这个方法主要是用来发起请求调用，传参除了上下文 context 之外，还有二进制的请求包 request，返回是一个二进制的完整数据帧。这里设计成 interface 接口的形式，同样是为了可插拔、支持业务自定义。</p>
<h3 id="二clientserver-通信">二、client/server 通信</h3>
<p>我们先从最简单也是最基础的 client/server 通信说起。一个简单 c/s 模型，server 主要功能是监听连接，处理请求，假如使用 tcp 协议实现，代码如下：</p>
<p><strong>server.go</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:8000&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">conn</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from client: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此时，client 使用 tcp 协议实现如下：</p>
<p><strong>client.go</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">conn</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span><span class="s">&#34;127.0.0.1:8000&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from server: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>运行 go run server.go ，然后另起终端运行 go run client.go，server 会收到 client 的 &ldquo;hello&rdquo; 请求，cilent 则会收到 server 的 &ldquo;world&rdquo; 响应。</p>
<h3 id="三问题延伸">三、问题延伸</h3>
<p>现在我们完成了一个基于 tcp 协议的 client/server 通讯服务。我们之前说到了，transport 的核心能力是提供 client 和 server 的底层通信实现。上面的代码已经实现了 client 和 server 互发消息，是不是已经达到我们的目标了呢？慢，我们之前的目标可是高性能，假如深入思考一下，它其实存在以下几个问题：</p>
<p>1、server 对请求的读写处理是同步的，假如这里同时有两个请求 A、B，只有等请求 A 的读写操作完全完成时，才能进行请求 B 的读写操作，这无疑产生了很严重的等待时间浪费。</p>
<p>2、server 每次监听到一个请求都会创建一个连接 conn，用 conn 去进行数据的读写，读写完成之后连接 conn 会被关闭，假如同时有成千上万个请求需要处理，每次请求都需要创建和销毁 conn 对象，会造成很大的性能损耗。</p>
<p>3、server 和 client 每次处理消息时，需要用到一块内存 buffer 用来进行消息读取，这一块内存也会存在频繁创建和销毁问题。</p>
<p>4、假如 client 或者 server 需要发送的数据包过大，tcp 协议会进行拆包，即把大的数据包拆成多份发送。假如 client 需要发送的数据包过小，tcp 协议底层会进行粘包，即多个数据包合并发送。这种情况下，上面的代码是无法支持的，会出现 client 或者 server 读取到的数据包不完整。</p>
<p>5、client 每次发送一个数据包都需要创建一个连接 conn，假设请求量过大，可能会出现单机连接数不够用的情况。</p>
<p>我们一步步来，逐一进行问题解决。</p>
<ul>
<li>要解决问题1，这里需要对 server 代码进行改造一下，使 server 的读写异步化，这里其实使用 go 语言的协程机制很方便实现，如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:8000&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">conn</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from client: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对连接 conn 的处理我们统一放到 handleConn 这个函数中，然后使用 go 关键字，新起一个协程去进行处理，这样就能实现异步化处理请求，避免了同步的时间浪费。</p>
<ul>
<li>要解决问题2，我们可以采用长连接的方式，每次 client 和 server 建立连接后，这个连接默认存活，只有在对端关闭连接时，或者连接一直空闲、超过指定时间没有发送消息时，这个连接才关闭。在连接的存活期内，对对端发来的请求进行循环读写，这样就能避免短连接不断创建和关闭造成的性能损耗。这里只需要更改上面的 handleConn 这个方法即可，如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// client 连接关闭</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from client: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用一个 for 循环对连接循环读取，当遇到 io.EOF 这个错误时，说明 client 已经关闭连接，循环退出，server 关闭这个连接。对空闲连接的检测放在 client 去做，这里先不讲解，放在连接池 pool 的章节进行介绍。</p>
<ul>
<li>要解决问题3，我们只需要初始化一块大内存，每次消息读取复用这块内存进行读取即可，比较简单，就不详细介绍了。</li>
<li>要解决问题4，这里需要两个机制，第一是当客户端包过大时，进行循环发包，直到包发完为止。第二是服务端调用 io.ReadFull 函数，保证读取到的包大小刚好等于客户端发过来的包大小，这样就能实现拆包粘包。对 client 代码改动如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">conn</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span><span class="s">&#34;127.0.0.1:8000&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from server: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">req</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">sendNum</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">   <span class="nx">num</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 循环发包</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">sendNum</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">num</span> <span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">req</span><span class="p">[</span><span class="nx">sendNum</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">sendNum</span> <span class="o">+=</span> <span class="nx">num</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">msg</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from server: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>同时，改动 server 的 handleConn 方法，使用 io.ReadFull 进行包读取，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 使用 io.ReadFull 进行包读取</span>
</span></span><span class="line"><span class="cl">      <span class="nx">recvNum</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// client 连接关闭</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">break</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">msg</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">recvNum</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;recv from client: &#34;</span><span class="p">,</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里需要注意的是假如包的大小没有达到指定的 buffer 大小， io.ReadFull 会在这里进行阻塞，一直等到读取完 buffer 大小的包然后再返回，所以这里需要提前知道包的长度，包的长度会在我们自定义协议的协议头里面可以获取到。</p>
<ul>
<li>要解决问题 5，我们可以采用连接池的方式进行连接复用，这里在讲解连接池 pool 的时候会详细讲解，这里就不进行赘述。</li>
</ul>
<h3 id="四对-udp-请求的处理">四、对 udp 请求的处理</h3>
<p>udp 请求跟 tcp 请求不同，udp 是无状态的协议。所以没有拆包粘包、长连接这些问题。因为 udp 的包最大不能超过 64 k，所以对 udp 的处理的原理就是 server 分配一块 64k 的内存，去进行包的接收，然后把响应数据发给对端，其他过程跟 tcp 类似，这里就不进行详细介绍，详情可以参考：<a href="https://github.com/lubanproj/gorpc/tree/master/transport">transport</a></p>
<h3 id="五与其他组件的交互">五、与其他组件的交互</h3>
<p>由于 client 请求需要向一个指定的 server ip 地址去发送消息，client 调用的时候可能是设置了服务名或者域名。那么首先要跟服务发现模块 resolver 交互，获取后端服务的地址列表，然后再根据客户端设置的负载均衡策略（轮询、随机、加权轮询、一致性哈希等），通过负载均衡算法得到一个 ip 地址。由于引入了连接池 pool 实现了客户端连接复用，所以每次请求需要通过连接池 pool 去获取一个连接 conn。同时，由于每次发送的包是一个附带了协议信息的完整消息，所以这里每次发包，需要调用 codec 的 encode 方法进行打包，每次收包，需要调用 codec 的 decode 方法进行解包。</p>
<p>所以 transport 这里，虽然是底层模块，但其实跟其他组件也是密不可分的，这些组件会在后续一一介绍。结合这些组件的完整代码可以参考：</p>
<p><a href="https://github.com/lubanproj/gorpc/blob/master/transport/client_transport.go">client_transport</a></p>
<p><a href="https://github.com/lubanproj/gorpc/blob/master/transport/server_transport.go">server_transport</a></p>
<h3 id="小结">小结</h3>
<p>这一章主要介绍了传输层 transport 的实现，从一个简单的 client/server 模型，到一个高性能的组件，再通过其他组件的交互，共同实现了一个高性能、高可用的 transport 组件。</p>

      </div>

      
      <div class="lesson-navigation">
        
        <div class="nav-buttons">
            <a href="https://diu.life/lessons/go-rpc/build-client/" class="nav-btn prev-btn">
              <span>← 上一章</span>
              <span class="nav-title">第四章：框架搭建 —— client</span>
            </a>
            <a href="https://diu.life/lessons/go-rpc/context-timeout/" class="nav-btn next-btn">
              <span>下一章 →</span>
              <span class="nav-title">第六章：超时机制</span>
            </a>
        </div>
      </div>
    </article>
  </div>
</div>

<style>
 
.main {
  max-width: 100% !important;
  padding: 0 !important;
}

.lesson-container {
  display: flex;
  min-height: calc(100vh - 60px);
  gap: 0;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
}

.lesson-sidebar {
  width: 320px;
  background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
  border-right: none;
  box-shadow: 2px 0 20px rgba(0, 0, 0, 0.08);
  position: sticky;
  top: 60px;
  height: calc(100vh - 60px);
  overflow-y: auto;
  padding: 30px 25px;
  z-index: 10;
}

.lesson-nav h3 {
  margin: 0 0 30px 0;
  color: #2c3e50;
  font-size: 1.4em;
  font-weight: 700;
  text-align: center;
  padding-bottom: 15px;
  border-bottom: 2px solid #e3f2fd;
  position: relative;
}

.lesson-nav h3::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.chapter-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.chapter-item {
  margin-bottom: 12px;
}

.chapter-link {
  display: block;
  padding: 16px 20px;
  color: #5a6c7d;
  text-decoration: none;
  border-radius: 12px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid transparent;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.chapter-link::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
  transition: left 0.5s;
}

.chapter-link:hover {
  background: rgba(255, 255, 255, 0.9);
  color: #2c3e50;
  transform: translateX(8px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.chapter-link:hover::before {
  left: 100%;
}

.chapter-item.active .chapter-link {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #ffffff;
  font-weight: 600;
  box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
  transform: translateX(8px);
}

.chapter-item.active .chapter-link::before {
  display: none;
}

.chapter-title {
  font-size: 0.95em;
  line-height: 1.5;
  font-weight: 500;
}

.lesson-content {
  flex: 1;
  padding: 40px 50px;
  width: 100%;
  overflow-x: auto;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  margin: 20px;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  position: relative;
}

.lesson-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  border-radius: 20px 20px 0 0;
}

.post-single {
  max-width: 100%;
  margin: 0;
}

.post-header {
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e8ecef;
}

.post-title {
  font-size: 2.2em;
  font-weight: 800;
  margin: 0 0 15px 0;
  color: #2c3e50;
  line-height: 1.3;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.post-meta {
  color: #7f8c8d;
  font-size: 0.95em;
  font-weight: 500;
}

.post-content {
  line-height: 1.8;
  color: #34495e;
  font-size: 1.05em;
}

.post-content h2 {
  margin-top: 50px;
  margin-bottom: 25px;
  font-size: 1.6em;
  font-weight: 700;
  color: #2c3e50;
  position: relative;
  padding-left: 20px;
}

.post-content h2::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 60%;
  background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
  border-radius: 2px;
}

.post-content h3 {
  margin-top: 35px;
  margin-bottom: 20px;
  font-size: 1.4em;
  font-weight: 600;
  color: #2c3e50;
}

.post-content p {
  margin-bottom: 20px;
  text-align: justify;
}

.post-content ul, .post-content ol {
  margin-bottom: 20px;
  padding-left: 25px;
}

.post-content li {
  margin-bottom: 10px;
  line-height: 1.7;
}

.post-content code {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.9em;
  color: #e83e8c;
  font-weight: 500;
  border: 1px solid #dee2e6;
}

.post-content pre {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  padding: 25px;
  border-radius: 12px;
  overflow-x: auto;
  margin: 30px 0;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  border: 1px solid #4a5568;
}

.post-content pre code {
  background: none;
  padding: 0;
  border-radius: 0;
  color: #a0aec0;
  border: none;
}

.lesson-navigation {
  margin-top: 60px;
  padding-top: 40px;
  border-top: 2px solid #e8ecef;
  position: relative;
}

.lesson-navigation::before {
  content: '';
  position: absolute;
  top: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.nav-buttons {
  display: flex;
  justify-content: space-between;
  gap: 25px;
}

.nav-btn {
  display: flex;
  flex-direction: column;
  padding: 20px 25px;
  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
  border: 2px solid #e9ecef;
  border-radius: 15px;
  text-decoration: none;
  color: #2c3e50;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex: 1;
  max-width: 320px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
}

.nav-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
  transition: left 0.6s;
}

.nav-btn:hover {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-color: #667eea;
  color: #ffffff;
  transform: translateY(-3px);
  box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
}

.nav-btn:hover::before {
  left: 100%;
}

.nav-btn span:first-child {
  font-size: 0.95em;
  color: #7f8c8d;
  margin-bottom: 8px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nav-btn:hover span:first-child {
  color: rgba(255, 255, 255, 0.9);
}

.nav-title {
  font-weight: 600;
  line-height: 1.4;
  font-size: 1.05em;
}

.next-btn {
  text-align: right;
}

@media (max-width: 768px) {
  .lesson-container {
    flex-direction: column;
    background: linear-gradient(180deg, #f5f7fa 0%, #c3cfe2 100%);
  }
  
  .lesson-sidebar {
    width: 100%;
    height: auto;
    position: static;
    border-right: none;
    border-bottom: 2px solid #e8ecef;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    padding: 25px 20px;
    margin: 0;
    border-radius: 0;
  }
  
  .lesson-content {
    max-width: 100%;
    padding: 30px 20px;
    margin: 15px;
    border-radius: 15px;
  }
  
  .post-title {
    font-size: 1.8em;
  }
  
  .post-content {
    font-size: 1em;
  }
  
  .nav-buttons {
    flex-direction: column;
    gap: 15px;
  }
  
  .nav-btn {
    max-width: 100%;
  }
  
  .next-btn {
    text-align: left;
  }
  
  .chapter-link:hover,
  .chapter-item.active .chapter-link {
    transform: none;
  }
}
</style>
    </main>
    
<footer class="footer">
    <div class="footer-content">
        <div class="footer-copyright">
                <span>&copy; 2024 丢哥 all rights reserved.</span>
        </div>
        <div class="footer-links">
            <a href="/privacy-policy/" title="隐私政策">隐私政策</a> |
            <a href="/terms-of-service/" title="服务条款">服务条款</a>
        </div>
    </div>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
