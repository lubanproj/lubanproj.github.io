<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>第六章：超时机制 | 丢哥</title>
<meta name="keywords" content="">
<meta name="description" content="一、超时
超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。

假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。
假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。

我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。">
<meta name="author" content="丢哥">
<link rel="canonical" href="https://www.diu.life/lessons/go-rpc/context-timeout/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.diu.life/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.diu.life/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.diu.life/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.diu.life/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.diu.life/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://www.diu.life/lessons/go-rpc/context-timeout/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://www.diu.life/lessons/go-rpc/context-timeout/">
  <meta property="og:site_name" content="丢哥">
  <meta property="og:title" content="第六章：超时机制">
  <meta property="og:description" content="一、超时 超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。
假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。 假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。 我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="lessons">
    <meta property="article:published_time" content="2020-02-06T00:00:00+08:00">
    <meta property="article:modified_time" content="2020-02-06T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第六章：超时机制">
<meta name="twitter:description" content="一、超时
超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。

假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。
假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。

我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "教程",
      "item": "https://www.diu.life/lessons/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从 0 到 1 开发一款高性能 RPC 框架",
      "item": "https://www.diu.life/lessons/go-rpc/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第六章：超时机制",
      "item": "https://www.diu.life/lessons/go-rpc/context-timeout/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第六章：超时机制",
  "name": "第六章：超时机制",
  "description": "一、超时 超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。\n假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。 假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。 我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。\n",
  "keywords": [
    
  ],
  "articleBody": "一、超时 超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。\n假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。 假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。 我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。\n那么我们的思路清楚了，最好的超时机制的实现应该是 client 和 server 同时处理超时。\n二、超时机制的设计 假如有一次请求，请求流程如下所示，A 同时调用了 B、C、D，C 同时调用了 E、F，E 调用了 G。\n假如整个请求的超时时间是 2s，那么我们就拿最长的一条链路 A ——\u003e C ——\u003e E ——\u003e G 来说，A 给下游链路的处理时间是 2s，假如 C 处理耗费了 1s，那么 C 给下游 E 的处理时间为 1s，假如 E 处理耗费了 0.5s ，那么留给下游 G 的处理时间就是 0.5s， 假如这条链路中出现下面任何一种情况，则这次请求视为超时：\nC 的处理时间超过了 2s E 的处理时间超过了 1s G 的处理时间超过了 0.5s 基于对上面请求流程的分析，我们就可以设计出我们的超时机制了，具体如下：\n客户端 client 一般是一条请求链路的源头。client 向下游发起调用，如果在规定时间内没有收到服务端的响应，则直接返回超时异常。\n对于一次请求的服务端 C 而言，请求从上游到 C 有一个上游传递下来的剩余处理时间。服务端 C 有一个自己处理请求的耗时，处理完之后，往下游发起调用时会有一个带给下游的剩余处理时间。这样，超时的信息就完成了上下游传递。也就是下面的等式：\n上游传递下来的剩余处理时间 - 服务端处理请求的时间 = 传递给下游的剩余处理时间\n三、超时机制的实现 上面我们详细讲解了超时机制的设计，那么我们要如何去实现这样一套超时机制呢？\n这里就介绍一下 go 里面一个非常强大的包 —— context\n1、什么是 context Context 是一个非常抽象的概念，中文翻译为 ”上下文“，为了方便理解，我们可以把它看做是 goroutine 的上下文。包括 goroutine 的运行状态、环境等信息。Context 可以用来在 goroutine 之间传递上下文信息，包括：信号、超时时间、k-v 键值对等。同时它可以用作并发控制。它的接口定义如下：\ntype Context interface { // 返回代表 Context 完成的时间 Deadline() (deadline time.Time, ok bool) // 当 Context 被取消或者死亡后，返回一个 channel Done() \u003c-chan struct{} // 当 Context 被取消或者死亡后，返回错误信息 Err() error // 获取 key 对应的 value Value(key interface{}) interface{} } 它主要有上面四个方法，通过 Deadline() 我们可以获取 Context 存活的时间。\n2、Context 的父子模型 要理解 Context ，必须要介绍下 Context 的父子模型。假如上图是在某个服务端 server 内进行请求处理的流程。 goroutine A 这里的 Context A 是 goroutine B、C、D 的 parent Context。goroutine E、F 与 goroutine C 共用 context C，Context C 是 Context G 的 parent Context。\nContext 的父子模型通俗点说就是，假如父 Context 已经执行完或者超时取消了，那么子 Context 相应地也会被取消。也就是说，上图假如 Context A 被取消了，那么 B、C、D 都会被取消，假如 Context C 被取消了，那么 Context G也会被取消。\n3、使用 context 包实现超时控制 使用 context 包实现超时控制，主要用到了下面两个函数：\ncontext.WithTimeout ：为 Context 设置超时时间，超过这个时间，Context 会被取消执行。 context.Deadline：返回 Context 完成的时间点。 具体实现：\n（1）client 端：\nclient 发起调用时，通过 client.WithTimeout 方法设置 client Options 参数选项的 timeout 参数的值。\n判断 client Options 参数选项的 timeout 值是否被设置，假如被设置，则通过 context.WithTimeout 方法设置 parent Context 的超时时间。\nif c.opts.timeout \u003e 0 { var cancel context.CancelFunc ctx, cancel = context.WithTimeout(ctx, c.opts.timeout) defer cancel() } 对下游链路发起调用，基于 parent Context 去生成子 Context 发起调用。\n（2）server 端：\nserver 端启动时，通过 server.WithTimeout 方法设置 service Options 参数选项的 timeout 参数的值。\nservice 在调用 Handle 方法处理请求时，判断 timeout 值是否被设置，假如被设置，则新起一个携带超时时间 timeout 的子 Context。\nif s.opts.timeout != 0 { var cancel context.CancelFunc ctx, cancel = context.WithTimeout(ctx, s.opts.timeout) defer cancel() } 通过这样一套机制，则实现了 client 和 server 双端的超时控制。\n小结 本章主要介绍了超时机制的原理、设计，并且借助 context 包实现了 client 和 server 的超时控制。\n",
  "wordCount" : "1740",
  "inLanguage": "zh",
  "datePublished": "2020-02-06T00:00:00+08:00",
  "dateModified": "2020-02-06T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "丢哥"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.diu.life/lessons/go-rpc/context-timeout/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "丢哥",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.diu.life/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.diu.life/" accesskey="h" title="丢哥 (Alt + H)">丢哥</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.diu.life/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/projects/" title="独立开发">
                    <span>独立开发</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/lessons/" title="教程">
                    <span>教程</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<div class="lesson-container">
  
  <div class="lesson-sidebar">
    <div class="lesson-nav">
      <h3>Go-Rpc 教程</h3>
      <ul class="chapter-list">
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/what-is-rpc/" class="chapter-link">
            <span class="chapter-title">第一章：RPC 原理</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/rpc-framework-overview/" class="chapter-link">
            <span class="chapter-title">第二章：RPC 框架概览</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-server/" class="chapter-link">
            <span class="chapter-title">第三章：框架搭建 —— server</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-client/" class="chapter-link">
            <span class="chapter-title">第四章：框架搭建 —— client</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-transport/" class="chapter-link">
            <span class="chapter-title">第五章：框架搭建 —— transport</span>
          </a>
        </li>
        <li class="chapter-item active">
          <a href="https://www.diu.life/lessons/go-rpc/context-timeout/" class="chapter-link">
            <span class="chapter-title">第六章：超时机制</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/custom-protocol/" class="chapter-link">
            <span class="chapter-title">第七章：自定义协议实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/codec/" class="chapter-link">
            <span class="chapter-title">第八章：协议编解码实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/marshal-and-unmarshal/" class="chapter-link">
            <span class="chapter-title">第九章：序列化实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/log-component/" class="chapter-link">
            <span class="chapter-title">第十章：日志模块实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/connection-pool/" class="chapter-link">
            <span class="chapter-title">第十一章：连接池实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/interceptor/" class="chapter-link">
            <span class="chapter-title">第十二章：拦截器实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/component-interface/" class="chapter-link">
            <span class="chapter-title">第十三章：组件可插拔实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/plugin/" class="chapter-link">
            <span class="chapter-title">第十四章：插件体系实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/service-discovery-selection/" class="chapter-link">
            <span class="chapter-title">第十五章：服务发现原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/service-discovery-implementation/" class="chapter-link">
            <span class="chapter-title">第十六章：服务发现实现 —— consul</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/load-balance-implementation/" class="chapter-link">
            <span class="chapter-title">第十七章：负载均衡实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/tracing-selection/" class="chapter-link">
            <span class="chapter-title">第十八章：分布式链路追踪原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/tracing-implementation/" class="chapter-link">
            <span class="chapter-title">第十九章：分布式链路追踪实现 —— jaeger</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/auth/" class="chapter-link">
            <span class="chapter-title">第二十章：认证鉴权实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/code-generation/" class="chapter-link">
            <span class="chapter-title">第二十一章：代码生成工具实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/performance-test/" class="chapter-link">
            <span class="chapter-title">第二十二章：框架性能测试</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/performance-optimization/" class="chapter-link">
            <span class="chapter-title">第二十三章：框架性能优化</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/summary/" class="chapter-link">
            <span class="chapter-title">第二十四章：总结与展望</span>
          </a>
        </li>
      </ul>
    </div>
  </div>

  
  <div class="lesson-content">
    <article class="post-single">
      <header class="post-header">
        <h1 class="post-title">第六章：超时机制</h1>
        <div class="post-meta">
          <time datetime="2020-02-06T00:00:00&#43;08:00">2020-02-06</time>
        </div>
      </header>

      <div class="post-content">
        <h3 id="一超时">一、超时</h3>
<p>超时是 rpc 请求中最常见的问题之一。一般发生超时的情况都是在涉及到跨系统调用的场景，假如具体划分，可以分为客户端调用超时和服务端超时。</p>
<ul>
<li>假如对客户端超时进行处理，那么当客户端发起请求后，如果在规定时间内没有收到服务端的响应，则直接返回给上游调用超时异常，此时服务端的代码可能仍在运行。</li>
<li>假如对服务端超时进行处理，那么当客户端发起一次请求后，会一直等待服务端响应，服务端在方法执行之后的指定时间内如果未执行完程序，则不会继续处理，而是直接返回一个超时异常给到客户端。</li>
</ul>
<p>我们发现，假如只对客户端进行超时处理，可能会出现一次 rpc 请求 client 返回异常了，server 还在运行，这是一种资源浪费。假如只对服务端进行超时处理，则 client 会循环等待收包，假如 server 的回包丢包了，会造成 client 死循环，这也是不合理的。</p>
<p>那么我们的思路清楚了，最好的超时机制的实现应该是 client 和 server 同时处理超时。</p>
<h3 id="二超时机制的设计">二、超时机制的设计</h3>
<p>假如有一次请求，请求流程如下所示，A 同时调用了 B、C、D，C 同时调用了 E、F，E 调用了 G。</p>
<p><img alt="img" loading="lazy" src="/images/go-rpc/6-1.jpg"></p>
<p>假如整个请求的超时时间是 2s，那么我们就拿最长的一条链路 A ——&gt; C ——&gt; E ——&gt; G 来说，A 给下游链路的处理时间是 2s，假如 C 处理耗费了 1s，那么 C 给下游 E 的处理时间为 1s，假如 E 处理耗费了 0.5s ，那么留给下游 G 的处理时间就是 0.5s， 假如这条链路中出现下面任何一种情况，则这次请求视为超时：</p>
<ul>
<li>C 的处理时间超过了 2s</li>
<li>E 的处理时间超过了 1s</li>
<li>G 的处理时间超过了 0.5s</li>
</ul>
<p>基于对上面请求流程的分析，我们就可以设计出我们的超时机制了，具体如下：</p>
<p><img alt="img" loading="lazy" src="/images/go-rpc/6-2.jpg"></p>
<p>客户端 client 一般是一条请求链路的源头。client 向下游发起调用，如果在规定时间内没有收到服务端的响应，则直接返回超时异常。</p>
<p>对于一次请求的服务端 C 而言，请求从上游到 C 有一个上游传递下来的剩余处理时间。服务端 C 有一个自己处理请求的耗时，处理完之后，往下游发起调用时会有一个带给下游的剩余处理时间。这样，超时的信息就完成了上下游传递。也就是下面的等式：</p>
<p>上游传递下来的剩余处理时间 - 服务端处理请求的时间 = 传递给下游的剩余处理时间</p>
<h3 id="三超时机制的实现">三、超时机制的实现</h3>
<p>上面我们详细讲解了超时机制的设计，那么我们要如何去实现这样一套超时机制呢？</p>
<p>这里就介绍一下 go 里面一个非常强大的包 —— context</p>
<h4 id="1什么是-context">1、什么是 context</h4>
<p>Context 是一个非常抽象的概念，中文翻译为 ”上下文“，为了方便理解，我们可以把它看做是 goroutine 的上下文。包括 goroutine 的运行状态、环境等信息。Context 可以用来在 goroutine 之间传递上下文信息，包括：信号、超时时间、k-v 键值对等。同时它可以用作并发控制。它的接口定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 返回代表 Context 完成的时间</span>
</span></span><span class="line"><span class="cl">   <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 当 Context 被取消或者死亡后，返回一个 channel</span>
</span></span><span class="line"><span class="cl">   <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 当 Context 被取消或者死亡后，返回错误信息</span>
</span></span><span class="line"><span class="cl">   <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 获取 key 对应的 value</span>
</span></span><span class="line"><span class="cl">   <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它主要有上面四个方法，通过 Deadline() 我们可以获取 Context 存活的时间。</p>
<h4 id="2context-的父子模型">2、Context 的父子模型</h4>
<p><img alt="img" loading="lazy" src="/images/go-rpc/6-3.jpg"></p>
<p>要理解 Context ，必须要介绍下 Context 的父子模型。假如上图是在某个服务端 server 内进行请求处理的流程。 goroutine A 这里的 Context A 是 goroutine B、C、D 的 parent Context。goroutine E、F 与 goroutine C 共用 context C，Context C 是 Context G 的 parent Context。</p>
<p>Context 的父子模型通俗点说就是，假如父 Context 已经执行完或者超时取消了，那么子 Context 相应地也会被取消。也就是说，上图假如 Context A 被取消了，那么 B、C、D 都会被取消，假如 Context C 被取消了，那么 Context G也会被取消。</p>
<h4 id="3使用-context-包实现超时控制">3、使用 context 包实现超时控制</h4>
<p>使用 context 包实现超时控制，主要用到了下面两个函数：</p>
<ul>
<li>context.WithTimeout ：为 Context 设置超时时间，超过这个时间，Context 会被取消执行。</li>
<li>context.Deadline：返回 Context 完成的时间点。</li>
</ul>
<p>具体实现：</p>
<p><strong>（1）client 端：</strong></p>
<ul>
<li>
<p>client 发起调用时，通过 client.WithTimeout 方法设置 client Options 参数选项的 timeout 参数的值。</p>
</li>
<li>
<p>判断 client Options 参数选项的 timeout 值是否被设置，假如被设置，则通过 context.WithTimeout 方法设置 parent Context 的超时时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">timeout</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kd">var</span> <span class="nx">cancel</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span>
</span></span><span class="line"><span class="cl">   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>对下游链路发起调用，基于 parent Context 去生成子 Context 发起调用。</p>
</li>
</ul>
<p><strong>（2）server 端：</strong></p>
<ul>
<li>
<p>server 端启动时，通过 server.WithTimeout 方法设置 service Options 参数选项的 timeout 参数的值。</p>
</li>
<li>
<p>service 在调用 Handle 方法处理请求时，判断 timeout 值是否被设置，假如被设置，则新起一个携带超时时间 timeout 的子 Context。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kd">var</span> <span class="nx">cancel</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span>
</span></span><span class="line"><span class="cl">   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<p>通过这样一套机制，则实现了 client 和 server 双端的超时控制。</p>
<h3 id="小结">小结</h3>
<p>本章主要介绍了超时机制的原理、设计，并且借助 context 包实现了 client 和 server 的超时控制。</p>

      </div>

      
      <div class="lesson-navigation">
        
        <div class="nav-buttons">
            <a href="https://www.diu.life/lessons/go-rpc/build-transport/" class="nav-btn prev-btn">
              <span>← 上一章</span>
              <span class="nav-title">第五章：框架搭建 —— transport</span>
            </a>
            <a href="https://www.diu.life/lessons/go-rpc/custom-protocol/" class="nav-btn next-btn">
              <span>下一章 →</span>
              <span class="nav-title">第七章：自定义协议实现</span>
            </a>
        </div>
      </div>
    </article>
  </div>
</div>

<style>
 
.main {
  max-width: 100% !important;
  padding: 0 !important;
}

.lesson-container {
  display: flex;
  min-height: calc(100vh - 60px);
  gap: 0;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
}

.lesson-sidebar {
  width: 320px;
  background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
  border-right: none;
  box-shadow: 2px 0 20px rgba(0, 0, 0, 0.08);
  position: sticky;
  top: 60px;
  height: calc(100vh - 60px);
  overflow-y: auto;
  padding: 30px 25px;
  z-index: 10;
}

.lesson-nav h3 {
  margin: 0 0 30px 0;
  color: #2c3e50;
  font-size: 1.4em;
  font-weight: 700;
  text-align: center;
  padding-bottom: 15px;
  border-bottom: 2px solid #e3f2fd;
  position: relative;
}

.lesson-nav h3::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.chapter-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.chapter-item {
  margin-bottom: 12px;
}

.chapter-link {
  display: block;
  padding: 16px 20px;
  color: #5a6c7d;
  text-decoration: none;
  border-radius: 12px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid transparent;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.chapter-link::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
  transition: left 0.5s;
}

.chapter-link:hover {
  background: rgba(255, 255, 255, 0.9);
  color: #2c3e50;
  transform: translateX(8px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.chapter-link:hover::before {
  left: 100%;
}

.chapter-item.active .chapter-link {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #ffffff;
  font-weight: 600;
  box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
  transform: translateX(8px);
}

.chapter-item.active .chapter-link::before {
  display: none;
}

.chapter-title {
  font-size: 0.95em;
  line-height: 1.5;
  font-weight: 500;
}

.lesson-content {
  flex: 1;
  padding: 40px 50px;
  width: 100%;
  overflow-x: auto;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  margin: 20px;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  position: relative;
}

.lesson-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  border-radius: 20px 20px 0 0;
}

.post-single {
  max-width: 100%;
  margin: 0;
}

.post-header {
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e8ecef;
}

.post-title {
  font-size: 2.2em;
  font-weight: 800;
  margin: 0 0 15px 0;
  color: #2c3e50;
  line-height: 1.3;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.post-meta {
  color: #7f8c8d;
  font-size: 0.95em;
  font-weight: 500;
}

.post-content {
  line-height: 1.8;
  color: #34495e;
  font-size: 1.05em;
}

.post-content h2 {
  margin-top: 50px;
  margin-bottom: 25px;
  font-size: 1.6em;
  font-weight: 700;
  color: #2c3e50;
  position: relative;
  padding-left: 20px;
}

.post-content h2::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 60%;
  background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
  border-radius: 2px;
}

.post-content h3 {
  margin-top: 35px;
  margin-bottom: 20px;
  font-size: 1.4em;
  font-weight: 600;
  color: #2c3e50;
}

.post-content p {
  margin-bottom: 20px;
  text-align: justify;
}

.post-content ul, .post-content ol {
  margin-bottom: 20px;
  padding-left: 25px;
}

.post-content li {
  margin-bottom: 10px;
  line-height: 1.7;
}

.post-content code {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.9em;
  color: #e83e8c;
  font-weight: 500;
  border: 1px solid #dee2e6;
}

.post-content pre {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  padding: 25px;
  border-radius: 12px;
  overflow-x: auto;
  margin: 30px 0;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  border: 1px solid #4a5568;
}

.post-content pre code {
  background: none;
  padding: 0;
  border-radius: 0;
  color: #a0aec0;
  border: none;
}

.lesson-navigation {
  margin-top: 60px;
  padding-top: 40px;
  border-top: 2px solid #e8ecef;
  position: relative;
}

.lesson-navigation::before {
  content: '';
  position: absolute;
  top: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.nav-buttons {
  display: flex;
  justify-content: space-between;
  gap: 25px;
}

.nav-btn {
  display: flex;
  flex-direction: column;
  padding: 20px 25px;
  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
  border: 2px solid #e9ecef;
  border-radius: 15px;
  text-decoration: none;
  color: #2c3e50;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex: 1;
  max-width: 320px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
}

.nav-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
  transition: left 0.6s;
}

.nav-btn:hover {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-color: #667eea;
  color: #ffffff;
  transform: translateY(-3px);
  box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
}

.nav-btn:hover::before {
  left: 100%;
}

.nav-btn span:first-child {
  font-size: 0.95em;
  color: #7f8c8d;
  margin-bottom: 8px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nav-btn:hover span:first-child {
  color: rgba(255, 255, 255, 0.9);
}

.nav-title {
  font-weight: 600;
  line-height: 1.4;
  font-size: 1.05em;
}

.next-btn {
  text-align: right;
}

@media (max-width: 768px) {
  .lesson-container {
    flex-direction: column;
    background: linear-gradient(180deg, #f5f7fa 0%, #c3cfe2 100%);
  }
  
  .lesson-sidebar {
    width: 100%;
    height: auto;
    position: static;
    border-right: none;
    border-bottom: 2px solid #e8ecef;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    padding: 25px 20px;
    margin: 0;
    border-radius: 0;
  }
  
  .lesson-content {
    max-width: 100%;
    padding: 30px 20px;
    margin: 15px;
    border-radius: 15px;
  }
  
  .post-title {
    font-size: 1.8em;
  }
  
  .post-content {
    font-size: 1em;
  }
  
  .nav-buttons {
    flex-direction: column;
    gap: 15px;
  }
  
  .nav-btn {
    max-width: 100%;
  }
  
  .next-btn {
    text-align: left;
  }
  
  .chapter-link:hover,
  .chapter-item.active .chapter-link {
    transform: none;
  }
}
</style>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.diu.life/">丢哥</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
