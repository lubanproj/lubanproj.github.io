<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>第七章：自定义协议实现 | 丢哥</title>
<meta name="keywords" content="">
<meta name="description" content="一、协议选型
协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。
之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。">
<meta name="author" content="丢哥">
<link rel="canonical" href="https://www.diu.life/lessons/go-rpc/custom-protocol/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.diu.life/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.diu.life/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.diu.life/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.diu.life/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.diu.life/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://www.diu.life/lessons/go-rpc/custom-protocol/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://www.diu.life/lessons/go-rpc/custom-protocol/">
  <meta property="og:site_name" content="丢哥">
  <meta property="og:title" content="第七章：自定义协议实现">
  <meta property="og:description" content="一、协议选型 协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。
之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="lessons">
    <meta property="article:published_time" content="2020-02-07T00:00:00+08:00">
    <meta property="article:modified_time" content="2020-02-07T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第七章：自定义协议实现">
<meta name="twitter:description" content="一、协议选型
协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。
之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "教程",
      "item": "https://www.diu.life/lessons/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从 0 到 1 开发一款高性能 RPC 框架",
      "item": "https://www.diu.life/lessons/go-rpc/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第七章：自定义协议实现",
      "item": "https://www.diu.life/lessons/go-rpc/custom-protocol/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第七章：自定义协议实现",
  "name": "第七章：自定义协议实现",
  "description": "一、协议选型 协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。\n之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。\n",
  "keywords": [
    
  ],
  "articleBody": "一、协议选型 协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。\n之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。\n第一种是直接使用业内比较成熟的协议，比如 http 协议。但是 http 是文本型协议，传输效率太低，所以可以考虑 http2 协议，http2 协议是二进制协议，传输效率远远超过 http1.x，例如 grpc 就是基于 http2 协议去做的协议定制，将 grpc 的一些协议信息封装在 http2 的帧信息里面进行传递。详细可参考：grpc 协议\n第二种是自定义一套二进制私有协议。这套私有协议专门为了这款 RPC 框架的 client 和 server 进行通信而生，这样可以更灵活地进行框架的协议定制，比如请求体和响应体等。这里经过考虑，我们选择了自定义私有协议，这样可以不用去兼容 HTTP 的帧格式，更方便协议的扩展。\n二、协议需要支持能力 自定义一套私有协议，首先我们需要考虑协议设计上应该需要支持的能力有哪些，如下：\n能力 诉求 高性能 协议的设计应该充分考虑传输的性能问题 可扩展 协议应该是可扩展的，支持版本迭代 超时控制 协议支持超时信息透传 认证鉴权 协议支持认证鉴权信息透传 流式 协议支持流式传输能力 数据压缩 协议支持数据报文压缩 tracing 协议支持 tracing 信息的透传 序列化 协议支持多种序列化方式 心跳 协议支持心跳请求的发送 ……. …… 这些能力算是一个优秀的 rpc 协议需要具备的基础能力。想清楚了这一部分，我们就可以开始我们的协议设计了。\n三、协议格式 一般的协议结构会分为帧头、协议包头、协议包体三个部分，帧头一般都是起到传输控制的作用，协议包头一般是用来传输一些需要在 client 和 server 之间进行透传的一些数据结构，比如序列化的方式、染色 key 等等。协议包体则是 client 发送的请求数据的二进制流或者是 server 返回的响应数据的二进制流。为了减少数据包的大小，一般尽可能节约帧头长度。在实现上面我们所说的协议需要支持的能力的基础上，我们将协议设置成以下形式。\n帧头 FrameHeader 的总长度为 15 byte\n第一个 1个 byte 为魔数，魔数是什么呢，看到网上有一段解释，觉得非常到位。魔数（magic number）一般是指硬写到代码里的整数常量，数值是编程者自己指定的，其他人不知道数值有什么具体意义，表示不明觉厉，就称作 magic number。这里主要是用来作为我们框架协议的一个唯一标识。\n第二个 1 byte 为版本号，我们上面说到了，协议应该是可扩展的，支持版本迭代。所以这里需要 1 byte 的版本号来进行版本迭代。\n第三个 1 byte 为消息类型，主要是用来区分普通消息和心跳消息。我们用 0x0 来表示普通消息，用 0x1 来表示心跳消息，客户端向服务端发送心跳包表示自己还是存活的。\n第四个 1 byte 表示请求类型，用 0x0 来表示一发一收，0x1 来表示只发不收，0x2 表示客户端流式请求，0x3 表示服务端流式请求，0x4 表示双向流式请求。\n第五个 1 byte 表示请求是否压缩，client 和 server 会根据这个标志位决定对传输的数据是否进行压缩/解压处理。0x0 默认不压缩，0x1 压缩\n第六个 2 byte 表示流 id ，这里是为了支持后续流式传输的能力，用 2 个字节进行表示。\n第七个 4 byte 表示消息的长度，用 4 个字节进行表示。\n第八个 4 byte 是保留位，这里留了 4个字节的保留位，方便后续协议进行扩展\n四、协议的实现 帧头的实现非常简单，只需要定义一个 go 的结构体就可以进行实现了，如下：\ntype FrameHeader struct { Magic uint8 // magic Version uint8 // version MsgType uint8 // msg type e.g. : 0x0: general req, 0x1: heartbeat ReqType uint8 // request type e.g. : 0x0: send and receive, 0x1: send but not receive, 0x2: client stream request, 0x3: server stream request, 0x4: bidirectional streaming request CompressType uint8 // compression or not : 0x0: not compression, 0x1: compression StreamID uint16 // stream ID Length uint32 // total packet length Reserved uint32 // 4 bytes reserved } 用了一个 FrameHeader 结构体定义帧头，只需要在打解包的时候，把帧头里面的属性按照顺序写入二进制流里面即可。\n对于包头和包体的实现，我们有两种思路。\n第一种是包头用一个数据结构表示，包体则是用一个 []byte 数组表示二进制流，这样在进行打解包的时候，只需要先将包头序列化成二进制，然后与二进制的包体数据进行拼接得到包头+包体数据，再前面拼接上二进制的帧头数据，即帧头+包头+包体，这就是一个完整的二进制帧。用 proto 文件定义如下：\n// 包头 message RequestHeader { string service_path = 1; // 请求服务路径 map\u003cstring, bytes\u003e metadata = 2; // 透传的数据 ... } // 包体 message RequestBody { bytes payload = 1 ; // 请求体 } 第二种则是包头和包体都放在同一个数据结构里面，包头里面的字段和表示包体的字段都是这个结构的属性。用 proto 文件定义如下：\n// 包头+包体 message Request { string service_path = 2; // 请求服务路径 map\u003cstring, bytes\u003e metadata = 3; // 透传的数据 bytes payload = 4; // 请求体 } 这里我们选择第二种方式实现，原因是压缩和序列化比较方便。\n实际上，由于请求和响应的包头里面所带的数据可能不一致，包头还可以分为请求头和响应头。框架中的请求头和响应头用 proto 定义如下：\nmessage Request { string service_path = 2; // 请求服务路径 map\u003cstring, bytes\u003e metadata = 3; // 透传的数据 bytes payload = 4; // 请求体 } message Response { uint32 ret_code = 1; // 返回码 0-正常 非0-错误 string ret_msg = 2; // 返回消息，OK-正常，错误会提示详情 map\u003cstring, bytes\u003e metadata = 3; // 透传的数据 bytes payload = 4; // 返回体 } 可以看到，client 发起请求时，请求头可能需要带上请求的服务路径 servicePath， servicePath 的格式是 /serviceName/method ，所以通过解析 servicePath 我们就可以获取服务名和方法名，server 需要根据服务名找到相应的 service 进行处理，需要根据方法名找到 service 相应的 handler 处理请求。 metadata 则是一个 k/v map，主要是透传一些 key/value 参数，比如染色 key 等。payload 是二进制请求体数据\nserver 返回响应时，主要包括一个是否正常的状态码 ret_code，以及返回的消息 ret_msg，同样会带一个 k/v map 结构的 metadata 进行参数透传。payload 是二进制响应体数据。\n小结 本章主要是从实现的角度介绍了如何进行协议选型、如何设计一款自定义私有协议。下一章会基于协议介绍数据的打解包实现。\n",
  "wordCount" : "2233",
  "inLanguage": "zh",
  "datePublished": "2020-02-07T00:00:00+08:00",
  "dateModified": "2020-02-07T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "丢哥"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.diu.life/lessons/go-rpc/custom-protocol/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "丢哥",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.diu.life/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.diu.life/" accesskey="h" title="丢哥 (Alt + H)">丢哥</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.diu.life/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/projects/" title="独立开发">
                    <span>独立开发</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/lessons/" title="教程">
                    <span>教程</span>
                </a>
            </li>
            <li>
                <a href="https://www.diu.life/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">
<div class="lesson-container">
  
  <div class="lesson-sidebar">
    <div class="lesson-nav">
      <h3>Go-Rpc 教程</h3>
      <ul class="chapter-list">
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/what-is-rpc/" class="chapter-link">
            <span class="chapter-title">第一章：RPC 原理</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/rpc-framework-overview/" class="chapter-link">
            <span class="chapter-title">第二章：RPC 框架概览</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-server/" class="chapter-link">
            <span class="chapter-title">第三章：框架搭建 —— server</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-client/" class="chapter-link">
            <span class="chapter-title">第四章：框架搭建 —— client</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/build-transport/" class="chapter-link">
            <span class="chapter-title">第五章：框架搭建 —— transport</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/context-timeout/" class="chapter-link">
            <span class="chapter-title">第六章：超时机制</span>
          </a>
        </li>
        <li class="chapter-item active">
          <a href="https://www.diu.life/lessons/go-rpc/custom-protocol/" class="chapter-link">
            <span class="chapter-title">第七章：自定义协议实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/codec/" class="chapter-link">
            <span class="chapter-title">第八章：协议编解码实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/marshal-and-unmarshal/" class="chapter-link">
            <span class="chapter-title">第九章：序列化实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/log-component/" class="chapter-link">
            <span class="chapter-title">第十章：日志模块实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/connection-pool/" class="chapter-link">
            <span class="chapter-title">第十一章：连接池实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/interceptor/" class="chapter-link">
            <span class="chapter-title">第十二章：拦截器实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/component-interface/" class="chapter-link">
            <span class="chapter-title">第十三章：组件可插拔实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/plugin/" class="chapter-link">
            <span class="chapter-title">第十四章：插件体系实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/service-discovery-selection/" class="chapter-link">
            <span class="chapter-title">第十五章：服务发现原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/service-discovery-implementation/" class="chapter-link">
            <span class="chapter-title">第十六章：服务发现实现 —— consul</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/load-balance-implementation/" class="chapter-link">
            <span class="chapter-title">第十七章：负载均衡实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/tracing-selection/" class="chapter-link">
            <span class="chapter-title">第十八章：分布式链路追踪原理及选型</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/tracing-implementation/" class="chapter-link">
            <span class="chapter-title">第十九章：分布式链路追踪实现 —— jaeger</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/auth/" class="chapter-link">
            <span class="chapter-title">第二十章：认证鉴权实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/code-generation/" class="chapter-link">
            <span class="chapter-title">第二十一章：代码生成工具实现</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/performance-test/" class="chapter-link">
            <span class="chapter-title">第二十二章：框架性能测试</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/performance-optimization/" class="chapter-link">
            <span class="chapter-title">第二十三章：框架性能优化</span>
          </a>
        </li>
        <li class="chapter-item ">
          <a href="https://www.diu.life/lessons/go-rpc/summary/" class="chapter-link">
            <span class="chapter-title">第二十四章：总结与展望</span>
          </a>
        </li>
      </ul>
    </div>
  </div>

  
  <div class="lesson-content">
    <article class="post-single">
      <header class="post-header">
        <h1 class="post-title">第七章：自定义协议实现</h1>
        <div class="post-meta">
          <time datetime="2020-02-07T00:00:00&#43;08:00">2020-02-07</time>
        </div>
      </header>

      <div class="post-content">
        <h3 id="一协议选型">一、协议选型</h3>
<p>协议是客户端和服务端之间对话的 “语言” ，是客户端和服务端双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。</p>
<p>之前 RPC 原理的章节说到了，关于 client 和 server 之间进行传输的协议选型，这里有两种方案。</p>
<p>第一种是直接使用业内比较成熟的协议，比如 http 协议。但是 http 是文本型协议，传输效率太低，所以可以考虑 http2 协议，http2 协议是二进制协议，传输效率远远超过 http1.x，例如 grpc 就是基于 http2 协议去做的协议定制，将 grpc 的一些协议信息封装在 http2 的帧信息里面进行传递。详细可参考：<a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">grpc 协议</a></p>
<p>第二种是自定义一套二进制私有协议。这套私有协议专门为了这款 RPC 框架的 client 和 server 进行通信而生，这样可以更灵活地进行框架的协议定制，比如请求体和响应体等。这里经过考虑，我们选择了自定义私有协议，这样可以不用去兼容 HTTP 的帧格式，更方便协议的扩展。</p>
<h3 id="二协议需要支持能力">二、协议需要支持能力</h3>
<p>自定义一套私有协议，首先我们需要考虑协议设计上应该需要支持的能力有哪些，如下：</p>
<table>
  <thead>
      <tr>
          <th>能力</th>
          <th>诉求</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>高性能</td>
          <td>协议的设计应该充分考虑传输的性能问题</td>
      </tr>
      <tr>
          <td>可扩展</td>
          <td>协议应该是可扩展的，支持版本迭代</td>
      </tr>
      <tr>
          <td>超时控制</td>
          <td>协议支持超时信息透传</td>
      </tr>
      <tr>
          <td>认证鉴权</td>
          <td>协议支持认证鉴权信息透传</td>
      </tr>
      <tr>
          <td>流式</td>
          <td>协议支持流式传输能力</td>
      </tr>
      <tr>
          <td>数据压缩</td>
          <td>协议支持数据报文压缩</td>
      </tr>
      <tr>
          <td>tracing</td>
          <td>协议支持 tracing 信息的透传</td>
      </tr>
      <tr>
          <td>序列化</td>
          <td>协议支持多种序列化方式</td>
      </tr>
      <tr>
          <td>心跳</td>
          <td>协议支持心跳请求的发送</td>
      </tr>
      <tr>
          <td>&hellip;&hellip;.</td>
          <td>&hellip;&hellip;</td>
      </tr>
  </tbody>
</table>
<p>这些能力算是一个优秀的 rpc 协议需要具备的基础能力。想清楚了这一部分，我们就可以开始我们的协议设计了。</p>
<h3 id="三协议格式">三、协议格式</h3>
<p>一般的协议结构会分为帧头、协议包头、协议包体三个部分，帧头一般都是起到传输控制的作用，协议包头一般是用来传输一些需要在 client 和 server 之间进行透传的一些数据结构，比如序列化的方式、染色 key 等等。协议包体则是 client 发送的请求数据的二进制流或者是 server 返回的响应数据的二进制流。为了减少数据包的大小，一般尽可能节约帧头长度。在实现上面我们所说的协议需要支持的能力的基础上，我们将协议设置成以下形式。</p>
<p><img alt="img" loading="lazy" src="/images/go-rpc/7-1.jpg"></p>
<p>帧头 FrameHeader 的总长度为 15 byte</p>
<p>第一个 1个 byte 为魔数，魔数是什么呢，看到网上有一段解释，觉得非常到位。魔数（magic number）一般是指硬写到代码里的整数常量，数值是编程者自己指定的，其他人不知道数值有什么具体意义，表示不明觉厉，就称作 magic number。这里主要是用来作为我们框架协议的一个唯一标识。</p>
<p>第二个 1 byte 为版本号，我们上面说到了，协议应该是可扩展的，支持版本迭代。所以这里需要 1 byte 的版本号来进行版本迭代。</p>
<p>第三个 1 byte 为消息类型，主要是用来区分普通消息和心跳消息。我们用 0x0 来表示普通消息，用 0x1 来表示心跳消息，客户端向服务端发送心跳包表示自己还是存活的。</p>
<p>第四个 1 byte 表示请求类型，用 0x0 来表示一发一收，0x1 来表示只发不收，0x2 表示客户端流式请求，0x3 表示服务端流式请求，0x4 表示双向流式请求。</p>
<p>第五个 1 byte 表示请求是否压缩，client 和 server 会根据这个标志位决定对传输的数据是否进行压缩/解压处理。0x0 默认不压缩，0x1 压缩</p>
<p>第六个 2 byte 表示流 id ，这里是为了支持后续流式传输的能力，用 2 个字节进行表示。</p>
<p>第七个 4 byte 表示消息的长度，用 4 个字节进行表示。</p>
<p>第八个 4 byte 是保留位，这里留了 4个字节的保留位，方便后续协议进行扩展</p>
<h3 id="四协议的实现">四、协议的实现</h3>
<p>帧头的实现非常简单，只需要定义一个 go 的结构体就可以进行实现了，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FrameHeader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Magic</span> <span class="kt">uint8</span>    <span class="c1">// magic</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Version</span> <span class="kt">uint8</span>  <span class="c1">// version</span>
</span></span><span class="line"><span class="cl">   <span class="nx">MsgType</span> <span class="kt">uint8</span>  <span class="c1">// msg type e.g. :   0x0: general req,  0x1: heartbeat</span>
</span></span><span class="line"><span class="cl">   <span class="nx">ReqType</span> <span class="kt">uint8</span>  <span class="c1">// request type e.g. :   0x0: send and receive,   0x1: send but not receive,  0x2: client stream request, 0x3: server stream request, 0x4: bidirectional streaming request</span>
</span></span><span class="line"><span class="cl">   <span class="nx">CompressType</span> <span class="kt">uint8</span> <span class="c1">// compression or not :  0x0: not compression,  0x1: compression</span>
</span></span><span class="line"><span class="cl">   <span class="nx">StreamID</span> <span class="kt">uint16</span>    <span class="c1">// stream ID</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Length</span> <span class="kt">uint32</span>      <span class="c1">// total packet length</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Reserved</span> <span class="kt">uint32</span>  <span class="c1">// 4 bytes reserved</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>用了一个 FrameHeader 结构体定义帧头，只需要在打解包的时候，把帧头里面的属性按照顺序写入二进制流里面即可。</p>
<p>对于包头和包体的实现，我们有两种思路。</p>
<p>第一种是包头用一个数据结构表示，包体则是用一个 []byte 数组表示二进制流，这样在进行打解包的时候，只需要先将包头序列化成二进制，然后与二进制的包体数据进行拼接得到包头+包体数据，再前面拼接上二进制的帧头数据，即帧头+包头+包体，这就是一个完整的二进制帧。用 proto 文件定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 包头</span>
</span></span><span class="line"><span class="cl"><span class="nx">message</span> <span class="nx">RequestHeader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span>  <span class="nx">service_path</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// 请求服务路径</span>
</span></span><span class="line"><span class="cl">    <span class="kd">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">&gt;</span> <span class="nx">metadata</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 透传的数据</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 包体</span>
</span></span><span class="line"><span class="cl"><span class="nx">message</span> <span class="nx">RequestBody</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	<span class="nx">bytes</span> <span class="nx">payload</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">;</span>   <span class="c1">// 请求体</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>                
</span></span></code></pre></div><p>第二种则是包头和包体都放在同一个数据结构里面，包头里面的字段和表示包体的字段都是这个结构的属性。用 proto 文件定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 包头+包体</span>
</span></span><span class="line"><span class="cl"><span class="nx">message</span> <span class="nx">Request</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span>  <span class="nx">service_path</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// 请求服务路径</span>
</span></span><span class="line"><span class="cl">    <span class="kd">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">&gt;</span> <span class="nx">metadata</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 透传的数据</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bytes</span>  <span class="nx">payload</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>               <span class="c1">// 请求体</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里我们选择第二种方式实现，原因是压缩和序列化比较方便。</p>
<p>实际上，由于请求和响应的包头里面所带的数据可能不一致，包头还可以分为请求头和响应头。框架中的请求头和响应头用 proto 定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">message</span> <span class="nx">Request</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span>  <span class="nx">service_path</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// 请求服务路径</span>
</span></span><span class="line"><span class="cl">    <span class="kd">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">&gt;</span> <span class="nx">metadata</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 透传的数据</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bytes</span>  <span class="nx">payload</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>               <span class="c1">// 请求体</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">message</span> <span class="nx">Response</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32</span> <span class="nx">ret_code</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>               <span class="c1">// 返回码 0-正常 非0-错误</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="nx">ret_msg</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>                 <span class="c1">// 返回消息，OK-正常，错误会提示详情</span>
</span></span><span class="line"><span class="cl">    <span class="kd">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">&gt;</span> <span class="nx">metadata</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1">// 透传的数据</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bytes</span> <span class="nx">payload</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>                 <span class="c1">// 返回体</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到，client 发起请求时，请求头可能需要带上请求的服务路径 servicePath， servicePath 的格式是 /serviceName/method ，所以通过解析 servicePath 我们就可以获取服务名和方法名，server 需要根据服务名找到相应的 service 进行处理，需要根据方法名找到 service 相应的 handler 处理请求。 metadata 则是一个 k/v map，主要是透传一些 key/value 参数，比如染色 key 等。payload 是二进制请求体数据</p>
<p>server 返回响应时，主要包括一个是否正常的状态码 ret_code，以及返回的消息 ret_msg，同样会带一个 k/v map 结构的 metadata 进行参数透传。payload 是二进制响应体数据。</p>
<h3 id="小结">小结</h3>
<p>本章主要是从实现的角度介绍了如何进行协议选型、如何设计一款自定义私有协议。下一章会基于协议介绍数据的打解包实现。</p>

      </div>

      
      <div class="lesson-navigation">
        
        <div class="nav-buttons">
            <a href="https://www.diu.life/lessons/go-rpc/context-timeout/" class="nav-btn prev-btn">
              <span>← 上一章</span>
              <span class="nav-title">第六章：超时机制</span>
            </a>
            <a href="https://www.diu.life/lessons/go-rpc/codec/" class="nav-btn next-btn">
              <span>下一章 →</span>
              <span class="nav-title">第八章：协议编解码实现</span>
            </a>
        </div>
      </div>
    </article>
  </div>
</div>

<style>
 
.main {
  max-width: 100% !important;
  padding: 0 !important;
}

.lesson-container {
  display: flex;
  min-height: calc(100vh - 60px);
  gap: 0;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
}

.lesson-sidebar {
  width: 320px;
  background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
  border-right: none;
  box-shadow: 2px 0 20px rgba(0, 0, 0, 0.08);
  position: sticky;
  top: 60px;
  height: calc(100vh - 60px);
  overflow-y: auto;
  padding: 30px 25px;
  z-index: 10;
}

.lesson-nav h3 {
  margin: 0 0 30px 0;
  color: #2c3e50;
  font-size: 1.4em;
  font-weight: 700;
  text-align: center;
  padding-bottom: 15px;
  border-bottom: 2px solid #e3f2fd;
  position: relative;
}

.lesson-nav h3::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.chapter-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.chapter-item {
  margin-bottom: 12px;
}

.chapter-link {
  display: block;
  padding: 16px 20px;
  color: #5a6c7d;
  text-decoration: none;
  border-radius: 12px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid transparent;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.chapter-link::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
  transition: left 0.5s;
}

.chapter-link:hover {
  background: rgba(255, 255, 255, 0.9);
  color: #2c3e50;
  transform: translateX(8px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.chapter-link:hover::before {
  left: 100%;
}

.chapter-item.active .chapter-link {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #ffffff;
  font-weight: 600;
  box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
  transform: translateX(8px);
}

.chapter-item.active .chapter-link::before {
  display: none;
}

.chapter-title {
  font-size: 0.95em;
  line-height: 1.5;
  font-weight: 500;
}

.lesson-content {
  flex: 1;
  padding: 40px 50px;
  width: 100%;
  overflow-x: auto;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  margin: 20px;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  position: relative;
}

.lesson-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  border-radius: 20px 20px 0 0;
}

.post-single {
  max-width: 100%;
  margin: 0;
}

.post-header {
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e8ecef;
}

.post-title {
  font-size: 2.2em;
  font-weight: 800;
  margin: 0 0 15px 0;
  color: #2c3e50;
  line-height: 1.3;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.post-meta {
  color: #7f8c8d;
  font-size: 0.95em;
  font-weight: 500;
}

.post-content {
  line-height: 1.8;
  color: #34495e;
  font-size: 1.05em;
}

.post-content h2 {
  margin-top: 50px;
  margin-bottom: 25px;
  font-size: 1.6em;
  font-weight: 700;
  color: #2c3e50;
  position: relative;
  padding-left: 20px;
}

.post-content h2::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 60%;
  background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
  border-radius: 2px;
}

.post-content h3 {
  margin-top: 35px;
  margin-bottom: 20px;
  font-size: 1.4em;
  font-weight: 600;
  color: #2c3e50;
}

.post-content p {
  margin-bottom: 20px;
  text-align: justify;
}

.post-content ul, .post-content ol {
  margin-bottom: 20px;
  padding-left: 25px;
}

.post-content li {
  margin-bottom: 10px;
  line-height: 1.7;
}

.post-content code {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.9em;
  color: #e83e8c;
  font-weight: 500;
  border: 1px solid #dee2e6;
}

.post-content pre {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  padding: 25px;
  border-radius: 12px;
  overflow-x: auto;
  margin: 30px 0;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  border: 1px solid #4a5568;
}

.post-content pre code {
  background: none;
  padding: 0;
  border-radius: 0;
  color: #a0aec0;
  border: none;
}

.lesson-navigation {
  margin-top: 60px;
  padding-top: 40px;
  border-top: 2px solid #e8ecef;
  position: relative;
}

.lesson-navigation::before {
  content: '';
  position: absolute;
  top: -2px;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 2px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
}

.nav-buttons {
  display: flex;
  justify-content: space-between;
  gap: 25px;
}

.nav-btn {
  display: flex;
  flex-direction: column;
  padding: 20px 25px;
  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
  border: 2px solid #e9ecef;
  border-radius: 15px;
  text-decoration: none;
  color: #2c3e50;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  flex: 1;
  max-width: 320px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
}

.nav-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
  transition: left 0.6s;
}

.nav-btn:hover {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-color: #667eea;
  color: #ffffff;
  transform: translateY(-3px);
  box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
}

.nav-btn:hover::before {
  left: 100%;
}

.nav-btn span:first-child {
  font-size: 0.95em;
  color: #7f8c8d;
  margin-bottom: 8px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nav-btn:hover span:first-child {
  color: rgba(255, 255, 255, 0.9);
}

.nav-title {
  font-weight: 600;
  line-height: 1.4;
  font-size: 1.05em;
}

.next-btn {
  text-align: right;
}

@media (max-width: 768px) {
  .lesson-container {
    flex-direction: column;
    background: linear-gradient(180deg, #f5f7fa 0%, #c3cfe2 100%);
  }
  
  .lesson-sidebar {
    width: 100%;
    height: auto;
    position: static;
    border-right: none;
    border-bottom: 2px solid #e8ecef;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    padding: 25px 20px;
    margin: 0;
    border-radius: 0;
  }
  
  .lesson-content {
    max-width: 100%;
    padding: 30px 20px;
    margin: 15px;
    border-radius: 15px;
  }
  
  .post-title {
    font-size: 1.8em;
  }
  
  .post-content {
    font-size: 1em;
  }
  
  .nav-buttons {
    flex-direction: column;
    gap: 15px;
  }
  
  .nav-btn {
    max-width: 100%;
  }
  
  .next-btn {
    text-align: left;
  }
  
  .chapter-link:hover,
  .chapter-item.active .chapter-link {
    transform: none;
  }
}
</style>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.diu.life/">丢哥</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
