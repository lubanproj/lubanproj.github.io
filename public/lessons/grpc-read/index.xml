<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>gRPC 源码阅读 on 丢哥</title>
    <link>http://localhost:1313/lessons/grpc-read/</link>
    <description>Recent content in gRPC 源码阅读 on 丢哥</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Nov 2019 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/lessons/grpc-read/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第十二章：grpc 数据流转</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-data-flow/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-data-flow/</guid>
      <description>&lt;h1 id=&#34;grpc-数据流转&#34;&gt;grpc 数据流转&lt;/h1&gt;
&lt;p&gt;阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 &lt;a href=&#34;https://github.com/lubanproj/grpc_read/blob/master/10-grpc%20%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.md&#34;&gt;《10 - grpc 协议编解码器》&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/lubanproj/grpc_read/blob/master/11-grpc%20%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E5%85%A8%E5%89%96%E6%9E%90.md&#34;&gt;《11 - grpc 协议解包过程全剖析》&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>第十一章：grpc 协议解包过程全剖析</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-protocol-unpacking-analysis/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-protocol-unpacking-analysis/</guid>
      <description>&lt;h3 id=&#34;http2-协议帧格式&#34;&gt;http2 协议帧格式&lt;/h3&gt;
&lt;p&gt;我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第十章：grpc 协议编解码器</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-protocol-codec/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-protocol-codec/</guid>
      <description>&lt;h3 id=&#34;协议编解码器&#34;&gt;协议编解码器&lt;/h3&gt;
&lt;p&gt;一般的协议都会包括协议头和协议体，对于业务而言，一般只关心需要发送的业务数据。所以，协议头的内容一般是框架自动帮忙填充。将业务数据包装成指定协议格式的数据包就是编码的过程，从指定协议格式中的数据包中取出业务数据的过程就是解码的过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第九章：grpc 拦截器实现</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-interceptor-implementation/</link>
      <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-interceptor-implementation/</guid>
      <description>&lt;h2 id=&#34;grpc-源码解读--从-0-到-1-实现拦截器&#34;&gt;grpc 源码解读 —— 从 0 到 1 实现拦截器&lt;/h2&gt;
&lt;p&gt;拦截器，通俗点说，就是在执行一段代码之前或者之后，去执行另外一段代码。
拦截器在业界知名框架中的运用非常普遍。包括 Spring 、Grpc 等框架中都有拦截器的实现。接下来我们想办法从 0 到 1 自己实现一个拦截器。以下的实现主要使用 go 语言讲解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第八章：grpc 认证鉴权——oauth2认证</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-auth-oauth2/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-auth-oauth2/</guid>
      <description>&lt;h2 id=&#34;grpc-认证鉴权--oauth2&#34;&gt;grpc 认证鉴权 —— oauth2&lt;/h2&gt;
&lt;p&gt;前面我们说了 tls 认证，tls 保证了 client 和 server 通信的安全性，但是无法做到接口级别的权限控制。例如有 A、B、C、D 四个系统，存在下面两个场景：
1、我们希望 A 可以访问 B、C 系统，但是不能访问 D 系统
2、B 系统提供了 b1、b2、b3 三个接口，我们希望 A 系统可以访问 b1、b2 接口，但是不能访问 b3 接口。
此时 tls 认证肯定是无法实现上面两个诉求的，对于这两个场景，grpc 提供了 oauth2 的认证方式。对 oauth2 不了解的同学可以参考 &lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&#34;&gt;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>第七章：grpc 认证鉴权——tls认证</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-auth-tls/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-auth-tls/</guid>
      <description>&lt;h2 id=&#34;grpc-认证鉴权&#34;&gt;grpc 认证鉴权&lt;/h2&gt;
&lt;p&gt;在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。&lt;/p&gt;
&lt;h3 id=&#34;1单体模式下的认证鉴权&#34;&gt;1、单体模式下的认证鉴权&lt;/h3&gt;
&lt;p&gt;在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第六章：grpc 负载均衡</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-load-balancing/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-load-balancing/</guid>
      <description>&lt;h3 id=&#34;grpc负载均衡&#34;&gt;grpc负载均衡&lt;/h3&gt;
&lt;h4 id=&#34;负载均衡流程&#34;&gt;负载均衡流程&lt;/h4&gt;
&lt;p&gt;grpc 官方的 doc 中介绍了，grpc 的负载均衡是基于一次请求而不是一次连接的。也就是说，假如所有的请求都来自同一个客户端的连接，这些请求还是会被均衡到所有服务器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第五章：grpc 服务发现</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-service-discovery/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-service-discovery/</guid>
      <description>&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;在了解 grpc 服务发现之前，我们先来了解一下服务发现的路由方式。一般来说，我们有客户端路由和代理层路由两种方式。&lt;/p&gt;
&lt;h4 id=&#34;客户端路由&#34;&gt;客户端路由&lt;/h4&gt;
&lt;p&gt;客户端路由模式，也就是调用方负责获取被调用方的地址信息，并使用相应的负载均衡算法发起请求。调用方访问服务注册服务，获取对应的服务 IP 地址和端口，可能还包括对应的服务负载信息（负载均衡算法、服务实例权重等）。调用方通过负载均衡算法选取其中一个发起请求。如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>第四章：grpc hello world client 解析</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-hello-world-client-analysis/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-hello-world-client-analysis/</guid>
      <description>&lt;h3 id=&#34;grpc-hello-world--client-解析&#34;&gt;grpc hello world  client 解析&lt;/h3&gt;
&lt;p&gt;上一节我们介绍了 grpc 输出 hello world 过程中 server 监听和处理请求的过程。这一节中我们将介绍 client 发出请求的过程。&lt;/p&gt;
&lt;p&gt;来先看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	// Set up a connection to the server.
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf(&amp;quot;did not connect: %v&amp;quot;, err)
	}
	defer conn.Close()
	c := pb.NewGreeterClient(conn)

	// Contact the server and print out its response.
	name := defaultName
	if len(os.Args) &amp;gt; 1 {
		name = os.Args[1]
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name})
	if err != nil {
		log.Fatalf(&amp;quot;could not greet: %v&amp;quot;, err)
	}
	log.Printf(&amp;quot;Greeting: %s&amp;quot;, r.Message)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 client 的建立也可以大致分为 3 步：&lt;/p&gt;</description>
    </item>
    <item>
      <title>第三章：grpc hello world server 解析</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-hello-world-server-analysis/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-hello-world-server-analysis/</guid>
      <description>&lt;h3 id=&#34;grpc-hello-world-server-解析&#34;&gt;grpc hello world server 解析&lt;/h3&gt;
&lt;p&gt;我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&amp;hellip;&amp;hellip;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第二章：grpc hello world</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-hello-world/</link>
      <pubDate>Sat, 02 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-hello-world/</guid>
      <description>&lt;h3 id=&#34;grpc-quick-start&#34;&gt;grpc quick start&lt;/h3&gt;
&lt;p&gt;我们分析 go 版本的 grpc 实现，所以这里主要讲解 grpc-go 的安装和使用&lt;/p&gt;
&lt;h4 id=&#34;1安装&#34;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;go 语言版本的 grpc 安装需要 1.6 以上的 go 版本，所以你需要先执行 go version 查看 go  版本，假如版本低于 1.6 则需要先升级。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第一章：grpc concepts &amp; http2</title>
      <link>http://localhost:1313/lessons/grpc-read/grpc-concepts-http2/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/grpc-concepts-http2/</guid>
      <description>&lt;h3 id=&#34;写在前面&#34;&gt;写在前面&lt;/h3&gt;
&lt;h4 id=&#34;grpc-介绍&#34;&gt;grpc 介绍&lt;/h4&gt;
&lt;p&gt;grpc 是 google 开源的一款高性能的 rpc 框架。github 上介绍如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;市面上的 rpc 框架数不胜数，包括 alibaba dubbo 和微博的 motan 等。grpc 能够在众多的框架中脱颖而出是跟其高性能是密切相关的。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/1-grpc-concepts--http2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/1-grpc-concepts--http2/</guid>
      <description>&lt;h3 id=&#34;写在前面&#34;&gt;写在前面&lt;/h3&gt;
&lt;h4 id=&#34;grpc-介绍&#34;&gt;grpc 介绍&lt;/h4&gt;
&lt;p&gt;grpc 是 google 开源的一款高性能的 rpc 框架。github 上介绍如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;市面上的 rpc 框架数不胜数，包括 alibaba dubbo 和微博的 motan 等。grpc 能够在众多的框架中脱颖而出是跟其高性能是密切相关的。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/10-grpc-%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/10-grpc-%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;协议编解码器&#34;&gt;协议编解码器&lt;/h3&gt;
&lt;p&gt;一般的协议都会包括协议头和协议体，对于业务而言，一般只关心需要发送的业务数据。所以，协议头的内容一般是框架自动帮忙填充。将业务数据包装成指定协议格式的数据包就是编码的过程，从指定协议格式中的数据包中取出业务数据的过程就是解码的过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/11-grpc-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E5%85%A8%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/11-grpc-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E5%85%A8%E5%89%96%E6%9E%90/</guid>
      <description>&lt;h3 id=&#34;http2-协议帧格式&#34;&gt;http2 协议帧格式&lt;/h3&gt;
&lt;p&gt;我们知道网络传输都是以二进制的形式，所以所有的协议底层的传输也是二进制。那么问题来了，client 往 server 发一个数据包，server 如何知道数据包是完成还是还在发送呢？又或者，假如一个数据包过大，client 需要拆成几个包发送，或者数据包过小，client 需要合成一个包发送，server 如何识别呢？为了解决这些问题，client 和 server 都会约定好一些双方都能理解的“规则“，这就是协议。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/12-grpc-%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/12-grpc-%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/</guid>
      <description>&lt;h1 id=&#34;grpc-数据流转&#34;&gt;grpc 数据流转&lt;/h1&gt;
&lt;p&gt;阅读本文的前提是你对 grpc 协议的编解码和 协议打解包过程都比较清楚了，假如不是很了解可以先去阅读 &lt;a href=&#34;https://github.com/lubanproj/grpc_read/blob/master/10-grpc%20%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.md&#34;&gt;《10 - grpc 协议编解码器》&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/lubanproj/grpc_read/blob/master/11-grpc%20%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E5%85%A8%E5%89%96%E6%9E%90.md&#34;&gt;《11 - grpc 协议解包过程全剖析》&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/2-grpc-hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/2-grpc-hello-world/</guid>
      <description>&lt;h3 id=&#34;grpc-quick-start&#34;&gt;grpc quick start&lt;/h3&gt;
&lt;p&gt;我们分析 go 版本的 grpc 实现，所以这里主要讲解 grpc-go 的安装和使用&lt;/p&gt;
&lt;h4 id=&#34;1安装&#34;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;go 语言版本的 grpc 安装需要 1.6 以上的 go 版本，所以你需要先执行 go version 查看 go  版本，假如版本低于 1.6 则需要先升级。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/3-grpc-hello-world-server-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/3-grpc-hello-world-server-%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h3 id=&#34;grpc-hello-world-server-解析&#34;&gt;grpc hello world server 解析&lt;/h3&gt;
&lt;p&gt;我们介绍 grpc quick start 时，通过快速启动一个 grpc server 端和 client 端，然后以 rpc 调用的方式输出一个 hello world。那么输出 hello world 需要经过哪些方法的处理呢？&amp;hellip;&amp;hellip;.这个我也不知道，所以我们先去瞅瞅源码，探究一下 hello world 的背后是连接是如何建立的，然后一起来解读这个问题哈哈。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/4-grpc-hello-world-client-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/4-grpc-hello-world-client-%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h3 id=&#34;grpc-hello-world--client-解析&#34;&gt;grpc hello world  client 解析&lt;/h3&gt;
&lt;p&gt;上一节我们介绍了 grpc 输出 hello world 过程中 server 监听和处理请求的过程。这一节中我们将介绍 client 发出请求的过程。&lt;/p&gt;
&lt;p&gt;来先看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	// Set up a connection to the server.
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf(&amp;quot;did not connect: %v&amp;quot;, err)
	}
	defer conn.Close()
	c := pb.NewGreeterClient(conn)

	// Contact the server and print out its response.
	name := defaultName
	if len(os.Args) &amp;gt; 1 {
		name = os.Args[1]
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name})
	if err != nil {
		log.Fatalf(&amp;quot;could not greet: %v&amp;quot;, err)
	}
	log.Printf(&amp;quot;Greeting: %s&amp;quot;, r.Message)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 client 的建立也可以大致分为 3 步：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/5-grpc-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/5-grpc-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid>
      <description>&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;在了解 grpc 服务发现之前，我们先来了解一下服务发现的路由方式。一般来说，我们有客户端路由和代理层路由两种方式。&lt;/p&gt;
&lt;h4 id=&#34;客户端路由&#34;&gt;客户端路由&lt;/h4&gt;
&lt;p&gt;客户端路由模式，也就是调用方负责获取被调用方的地址信息，并使用相应的负载均衡算法发起请求。调用方访问服务注册服务，获取对应的服务 IP 地址和端口，可能还包括对应的服务负载信息（负载均衡算法、服务实例权重等）。调用方通过负载均衡算法选取其中一个发起请求。如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/6-grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/6-grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>&lt;h3 id=&#34;grpc负载均衡&#34;&gt;grpc负载均衡&lt;/h3&gt;
&lt;h4 id=&#34;负载均衡流程&#34;&gt;负载均衡流程&lt;/h4&gt;
&lt;p&gt;grpc 官方的 doc 中介绍了，grpc 的负载均衡是基于一次请求而不是一次连接的。也就是说，假如所有的请求都来自同一个客户端的连接，这些请求还是会被均衡到所有服务器。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/7-grpc-%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83tls%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/7-grpc-%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83tls%E8%AE%A4%E8%AF%81/</guid>
      <description>&lt;h2 id=&#34;grpc-认证鉴权&#34;&gt;grpc 认证鉴权&lt;/h2&gt;
&lt;p&gt;在了解 grpc 认证鉴权之前，我们有必要先梳理一下认证鉴权方面的知识。&lt;/p&gt;
&lt;h3 id=&#34;1单体模式下的认证鉴权&#34;&gt;1、单体模式下的认证鉴权&lt;/h3&gt;
&lt;p&gt;在单体模式下，整个应用是一个进程，应用一般只需要一个统一的安全认证模块来实现用户认证鉴权。例如用户登陆时，安全模块验证用户名和密码的合法性。假如合法，为用户生成一个唯一的 Session。将 SessionId 返回给客户端，客户端一般将 SessionId 以 Cookie 的形式记录下来，并在后续请求中传递 Cookie 给服务端来验证身份。为了避免 Session Id被第三者截取和盗用，客户端和应用之前应使用 TLS 加密通信，session 也会设置有过期时间。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/8-grpc-%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83oauth2%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/8-grpc-%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83oauth2%E8%AE%A4%E8%AF%81/</guid>
      <description>&lt;h2 id=&#34;grpc-认证鉴权--oauth2&#34;&gt;grpc 认证鉴权 —— oauth2&lt;/h2&gt;
&lt;p&gt;前面我们说了 tls 认证，tls 保证了 client 和 server 通信的安全性，但是无法做到接口级别的权限控制。例如有 A、B、C、D 四个系统，存在下面两个场景：
1、我们希望 A 可以访问 B、C 系统，但是不能访问 D 系统
2、B 系统提供了 b1、b2、b3 三个接口，我们希望 A 系统可以访问 b1、b2 接口，但是不能访问 b3 接口。
此时 tls 认证肯定是无法实现上面两个诉求的，对于这两个场景，grpc 提供了 oauth2 的认证方式。对 oauth2 不了解的同学可以参考 &lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&#34;&gt;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/lessons/grpc-read/9-grpc-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/lessons/grpc-read/9-grpc-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h2 id=&#34;grpc-源码解读--从-0-到-1-实现拦截器&#34;&gt;grpc 源码解读 —— 从 0 到 1 实现拦截器&lt;/h2&gt;
&lt;p&gt;拦截器，通俗点说，就是在执行一段代码之前或者之后，去执行另外一段代码。
拦截器在业界知名框架中的运用非常普遍。包括 Spring 、Grpc 等框架中都有拦截器的实现。接下来我们想办法从 0 到 1 自己实现一个拦截器。以下的实现主要使用 go 语言讲解。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
